<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <style>body {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
  /* do not increase min-width as some may use split screens */
  min-width: 800px;
  color: #999;
}

h1 {
  font-size: 24px;
  color: black;
}

h2 {
  font-size: 16px;
  color: black;
}

p {
  color: black;
}

a {
  color: #999;
}

table {
  border-collapse: collapse;
}

/******************************
 * SUMMARY INFORMATION
 ******************************/
#environment td {
  padding: 5px;
  border: 1px solid #E6E6E6;
}
#environment tr:nth-child(odd) {
  background-color: #f6f6f6;
}

/******************************
 * TEST RESULT COLORS
 ******************************/
span.passed,
.passed .col-result {
  color: green;
}

span.skipped,
span.xfailed,
span.rerun,
.skipped .col-result,
.xfailed .col-result,
.rerun .col-result {
  color: orange;
}

span.error,
span.failed,
span.xpassed,
.error .col-result,
.failed .col-result,
.xpassed .col-result {
  color: red;
}

/******************************
 * RESULTS TABLE
 *
 * 1. Table Layout
 * 2. Extra
 * 3. Sorting items
 *
 ******************************/
/*------------------
 * 1. Table Layout
 *------------------*/
#results-table {
  border: 1px solid #e6e6e6;
  color: #999;
  font-size: 12px;
  width: 100%;
}
#results-table th,
#results-table td {
  padding: 5px;
  border: 1px solid #E6E6E6;
  text-align: left;
}
#results-table th {
  font-weight: bold;
}

/*------------------
 * 2. Extra
 *------------------*/
.log {
  background-color: #e6e6e6;
  border: 1px solid #e6e6e6;
  color: black;
  display: block;
  font-family: "Courier New", Courier, monospace;
  height: 230px;
  overflow-y: scroll;
  padding: 5px;
  white-space: pre-wrap;
}
.log:only-child {
  height: inherit;
}

div.image {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.image img {
  width: 320px;
}

div.video {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.video video {
  overflow: hidden;
  width: 320px;
  height: 240px;
}

.collapsed {
  display: none;
}

.expander::after {
  content: " (show details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

.collapser::after {
  content: " (hide details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

/*------------------
 * 3. Sorting items
 *------------------*/
.sortable {
  cursor: pointer;
}

.sort-icon {
  font-size: 0px;
  float: left;
  margin-right: 5px;
  margin-top: 5px;
  /*triangle*/
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
}
.inactive .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #E6E6E6;
}
.asc.active .sort-icon {
  /*finish triangle*/
  border-bottom: 8px solid #999;
}
.desc.active .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #999;
}
</style></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report.html</h1>
    <p>Report generated on 02-Mar-2021 at 21:52:49 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "0.13.1", "py": "1.10.0", "pytest": "6.2.2"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Linux-5.10.18-200.fc33.x86_64-x86_64-with-glibc2.32</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"asyncio": "0.14.0", "html": "3.1.1", "metadata": "1.11.0"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.9.1</td></tr></table>
    <h2>Summary</h2>
    <p>50 tests ran in 137.61 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">13 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">37 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:xz35-jznz-q9yu-ply]</td>
          <td class="col-duration">3.29</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:btcr:xz35-jznz-q9yu-ply&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ... &#x27;020a5a5c8c3575489cd2c17d43f642fc2b34792d47c9b026fafe33b3469e31b841&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:xkrn-xz7q-qsye-28p]</td>
          <td class="col-duration">11.76</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:btcr:xkrn-xz7q-qsye-28p&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ...79e1bde881c15edc82b7c4d0d04441c5e7f6dce4b703f43c5d5c12948df32d2&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}, ...]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 3: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 4: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 5: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 6: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:x705-jznz-q3nl-srs]</td>
          <td class="col-duration">3.17</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:btcr:x705-jznz-q3nl-srs&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ... &#x27;02e0e01a8c302976e1556e95c54146e8464adac8626a5d29474718a7281133ff49&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:sov:WRfXPg8dantKVubE3HX8pw]</td>
          <td class="col-duration">0.95</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:sov:WRfXPg8dantKVubE3HX8pw&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;Ed25519SignatureAuthentication2018&#x27;], &#x27;verificationMethod&#x27;: &#x27;did:sov:WRfXPg8dantKVubE3H...pw#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&#x27;, &#x27;type&#x27;: [&#x27;Ed25519VerificationKey2018&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}, 1: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E]</td>
          <td class="col-duration">0.67</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E: Driver reported for did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E: Cannot retrieve keys for address 2F2B37C890824242Cb9B0FE5614fA2221B79901E on network ropsten: Cannot look up keys: class java.lang.String cannot be cast to class java.util.List (java.lang.String and java.util.List are in module java.base of loader &#x27;bootstrap&#x27;)</span><br/><br/>http_uniresolver/http_universal.py:75: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm]</td>
          <td class="col-duration">30.03</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7f216f161080&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7f216f1e2c40&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7f216f1bf9a0&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-35&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-35&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0]</td>
          <td class="col-duration">0.31</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs5...Secp256k1VerificationKey2018&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://core.blockstack.org&#x27;, &#x27;type&#x27;: &#x27;blockstack&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736]</td>
          <td class="col-duration">0.37</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736#controller&#x27;, &#x27;type&#x27;: &#x27;Secp256k1...ey&#x27;: [&lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216efb5be0&gt;]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: nacl is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[ssi.labs.nic.at]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;ssi.labs.nic.at&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:65: in resolve<br/>    did = DID(did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DID ssi.labs.nic.at&gt;, did = &#x27;ssi.labs.nic.at&#x27;<br/><br/>    def __init__(self, did: str):<br/>        &quot;&quot;&quot;Validate and parse raw DID str.&quot;&quot;&quot;<br/>        self._raw = did<br/>        matched = DID_PATTERN.fullmatch(did)<br/>        if not matched:<br/>&gt;           raise InvalidDIDError(&quot;Unable to parse DID {}&quot;.format(did))<br/><span class="error">E           aries_cloudagent.resolver.did.InvalidDIDError: Unable to parse DID ssi.labs.nic.at</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/did.py:138: InvalidDIDError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21]</td>
          <td class="col-duration">0.82</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21#keys-1&#x27;, ...9dde54242d3b1845d16742d62189c6700b6ab46e24743e9738c04bf5c6c0f2ba208c4ecda65166d3e4563da01fd7f811715cd5fbc3&#x27;, ...}, ...}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: hcr is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: neoid is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw]</td>
          <td class="col-duration">1.77</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw#key-1&#x27;], &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;id&#x27;: &#x27;did:ccp...f1cd4944dfb93&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd]</td>
          <td class="col-duration">0.50</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd#key-1&#x27;], &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;id&#x27;: &#x27;did:cc...843931c877e7f&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:work:2UUHQCd4psvkPLZGnWY33L]</td>
          <td class="col-duration">0.73</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:work:2UUHQCd4psvkPLZGnWY33L&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:work:2UUHQCd4psvkPLZGnWY33L&#x27;, &#x27;publicKey&#x27;: [&lt;aries_cloudagent.connections.models.diddoc_v2.verification_me...ceEndpoint&#x27;: &#x27;did:work:8RcWPSBtB4QwfC68yneDxC;id=860285e2-183d-4fe3-9767-babc744396b8;version=1.0&#x27;, &#x27;type&#x27;: &#x27;schema&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH]</td>
          <td class="col-duration">0.69</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216f2eac70&gt;, id = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH#keys-1&#x27;<br/>type = &#x27;EcdsaSecp256r1VerificationKey2019&#x27;, controller = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;023b041dfc2d00a9846d291dd4bad3f32b8c13a6ad8dc2e97fd711888ed7818c66&#x27;}, key_type = None<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>            key_type = PublicKeyType.get(type)<br/>            if not key_type:<br/>&gt;               raise ValueError(<br/>                    f&quot;Unexpected key type {type} for verification method &quot;<br/>                    f&quot;{self.serialize()}&quot;<br/>                )<br/><span class="error">E               ValueError: Unexpected key type EcdsaSecp256r1VerificationKey2019 for verification method {&#x27;controller&#x27;: &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256r1VerificationKey2019&#x27;, &#x27;id&#x27;: &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH#keys-1&#x27;}</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:67: ValueError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx]</td>
          <td class="col-duration">0.73</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216ef490a0&gt;, id = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-2&#x27;<br/>type = &#x27;X25519Salsa20Poly1305Key2018&#x27;, controller = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;0xd0a90ed3b87db1ab599bd3cc0c8e0dc7ffcf2347299a6d494567a14f06861952&#x27;}, key_type = None<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>            key_type = PublicKeyType.get(type)<br/>            if not key_type:<br/>&gt;               raise ValueError(<br/>                    f&quot;Unexpected key type {type} for verification method &quot;<br/>                    f&quot;{self.serialize()}&quot;<br/>                )<br/><span class="error">E               ValueError: Unexpected key type X25519Salsa20Poly1305Key2018 for verification method {&#x27;controller&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, &#x27;type&#x27;: &#x27;X25519Salsa20Poly1305Key2018&#x27;, &#x27;id&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-2&#x27;}</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:67: ValueError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734]</td>
          <td class="col-duration">0.98</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [&#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734#key-1&#x27;], &#x27;id&#x27;: &#x27;did:evan:testcore:0x...60fd734#randomService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/770853367&#x27;, &#x27;type&#x27;: &#x27;randomService-770853367&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:echo:1.1.25.0]</td>
          <td class="col-duration">0.23</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:echo:1.1.25.0&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:echo:1.1.25.0&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:echo:1.1.25.0: Driver reported for did:echo:1.1.25.0: IO exception! Can be invalid json response! testnet.echo-dev.io</span><br/><br/>http_uniresolver/http_universal.py:75: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p]</td>
          <td class="col-duration">0.18</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p: Cannot retrieve RESOLVE RESULT for did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p from http://dock-did-driver:8080/1.0/identifiers/did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p: Connect to dock-did-driver:8080 [dock-did-driver/10.100.68.233] failed: Connection refused (Connection refused)</span><br/><br/>http_uniresolver/http_universal.py:75: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE]</td>
          <td class="col-duration">0.79</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE#owner&#x27;], &#x27;type&#x27;: &#x27;Ed25519SignatureAut...btnetwork.io&#x27;, &#x27;type&#x27;: &#x27;DIDResolver&#x27;}, {&#x27;serviceEndpoint&#x27;: &#x27;https://explorer.abtnetwork.io&#x27;, &#x27;type&#x27;: &#x27;BlockExplorer&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}, 1: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None<br/>did = &lt;DID did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: trustbloc is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: sirius is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: mpg is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ]</td>
          <td class="col-duration">30.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7f216f1f76c0&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7f216f143340&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7f216f273be0&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-129&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-129&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA]</td>
          <td class="col-duration">30.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, profile = None, did = &lt;DID did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:67: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7f216f3b3740&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7f216ef4f280&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7f216f28d2e0&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-133&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-133&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 30<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A]</td>
          <td class="col-duration">1.13</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216f239e20&gt;, id = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A#owner&#x27;<br/>type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, controller = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;0355237d4af6afc7f139e396329d56a4d1235c94abde9a25782241774c06cccfb6&#x27;}, key_type = None<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>            key_type = PublicKeyType.get(type)<br/>            if not key_type:<br/>&gt;               raise ValueError(<br/>                    f&quot;Unexpected key type {type} for verification method &quot;<br/>                    f&quot;{self.serialize()}&quot;<br/>                )<br/><span class="error">E               ValueError: Unexpected key type EcdsaSecp256k1VerificationKey2019 for verification method {&#x27;controller&#x27;: &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, &#x27;id&#x27;: &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A#owner&#x27;}</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:67: ValueError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf]</td>
          <td class="col-duration">1.54</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf#zAHd7ePaivnaJLK...8321c11ec99403cf#openid&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/&#x27;, &#x27;type&#x27;: &#x27;OpenIdConnectVersion1.0Service&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044]</td>
          <td class="col-duration">1.54</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:47ef0...rmBJWLeECW&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;12nP26c2mLZ4QfB2FMzLRCM8hRaGGB6QufwqM2YKj1R8&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg]</td>
          <td class="col-duration">0.26</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>&gt;                   raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/><span class="error">E                   aries_cloudagent.resolver.base.DIDNotFound: did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg not found by HTTPUniversalDIDResolver</span><br/><br/>http_uniresolver/http_universal.py:72: DIDNotFound<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bid:6cc796b8d6e2fbebc9b3cf9e]</td>
          <td class="col-duration">0.88</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:bid:6cc796b8d6e2fbebc9b3cf9e&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None, did = &lt;DID did:bid:6cc796b8d6e2fbebc9b3cf9e&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:bid:6cc796b8d6e2fbebc9b3cf9e: Driver reported for did:bid:6cc796b8d6e2fbebc9b3cf9e: Cannot retrieve DDO for `did:bid:6cc796b8d6e2fbebc9b3cf9e` from `http://did.bidspace.cn: HTTP/1.1 502 Bad Gateway</span><br/><br/>http_uniresolver/http_universal.py:75: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoiYW55U2lnbmluZ0tleUlkIiwiandrIjp7ImNydiI6InNlY3AyNTZrMSIsImt0eSI6IkVDIiwieCI6ImFHc01HMHU5Rlg2STU0cGVJS3FZb2tqblFQR2hMVVlUT1FOYzNuT3ZFMVEiLCJ5IjoiZmppbHFoZVdRWWtITkU3MHNoTVJ5TURyWnA4RUdDZkVfYUwzaC15Sm1RQSJ9LCJwdXJwb3NlIjpbImF1dGgiLCJnZW5lcmFsIl0sInR5cGUiOiJFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkifV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJlbmRwb2ludCI6Imh0dHA6Ly9hbnkuZW5kcG9pbnQiLCJpZCI6ImFueVNlcnZpY2VFbmRwb2ludElkIiwidHlwZSI6ImFueVR5cGUifV19fV0sInVwZGF0ZV9jb21taXRtZW50IjoiRWlERkM2RE9Ed0JNeG5kX19oMTFSeDRObjFlOHpubFlPUjJhLVBqeUNva2NGZyJ9LCJzdWZmaXhfZGF0YSI6eyJkZWx0YV9oYXNoIjoiRWlBbExNMC1qem1DWi1FcElVZ0laQ2piWk5yMDFfVVBMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19]</td>
          <td class="col-duration">0.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;<br/>did = &#x27;did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW...BMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, _profile = None<br/>did = &lt;DID did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG...BMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoiYW55U2lnbmluZ0tleUlkIiwiandrIjp7ImNydiI6InNlY3AyNTZrMSIsImt0eSI6IkVDIiwieCI6ImFHc01HMHU5Rlg2STU0cGVJS3FZb2tqblFQR2hMVVlUT1FOYzNuT3ZFMVEiLCJ5IjoiZmppbHFoZVdRWWtITkU3MHNoTVJ5TURyWnA4RUdDZkVfYUwzaC15Sm1RQSJ9LCJwdXJwb3NlIjpbImF1dGgiLCJnZW5lcmFsIl0sInR5cGUiOiJFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkifV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJlbmRwb2ludCI6Imh0dHA6Ly9hbnkuZW5kcG9pbnQiLCJpZCI6ImFueVNlcnZpY2VFbmRwb2ludElkIiwidHlwZSI6ImFueVR5cGUifV19fV0sInVwZGF0ZV9jb21taXRtZW50IjoiRWlERkM2RE9Ed0JNeG5kX19oMTFSeDRObjFlOHpubFlPUjJhLVBqeUNva2NGZyJ9LCJzdWZmaXhfZGF0YSI6eyJkZWx0YV9oYXNoIjoiRWlBbExNMC1qem1DWi1FcElVZ0laQ2piWk5yMDFfVVBMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19: {&quot;message&quot;:&quot;Bad Request&quot;,&quot;type&quot;:&quot;request_resolve_identifier&quot;,&quot;code&quot;:&quot;remote_service_error&quot;,&quot;correlationId&quot;:&quot;0HM6THCNO6DI0:00000001&quot;}</span><br/><br/>http_uniresolver/http_universal.py:75: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3]</td>
          <td class="col-duration">0.83</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216ee7b6d0&gt;<br/>id = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-1&#x27;, type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;<br/>controller = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyJwk&#x27;: &#x27;{&quot;kty&quot;:&quot;EC&quot;,&quot;crv&quot;:&quot;secp256k1&quot;,&quot;x&quot;:&quot;qdVu4dIjLSS2A_dEp7DYovzoTgFSw309yLTrZanR0Mo&quot;,&quot;y&quot;:&quot;jAhMNEKzvITyyXI...EqdVu4dIjLSS2A/dEp7DYovzoTgFSw309yLTrZanR0MqM\nCEw0QrO8hPLJcivXZ6YULPlKIK9LBP2rFNEpWIpgWQ==\n-----END PUBLIC KEY-----&#x27;}<br/>key_type = None<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>            key_type = PublicKeyType.get(type)<br/>            if not key_type:<br/>&gt;               raise ValueError(<br/>                    f&quot;Unexpected key type {type} for verification method &quot;<br/>                    f&quot;{self.serialize()}&quot;<br/>                )<br/><span class="error">E               ValueError: Unexpected key type EcdsaSecp256k1VerificationKey2019 for verification method {&#x27;controller&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-1&#x27;}</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:67: ValueError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c154ef0c78]</td>
          <td class="col-duration">0.39</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c154ef0c78&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;MyIdEventVerifier&#x27;]}], &#x27;id&#x27;: &#x27;did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c1...+kM6dnIiTWjy+X4IDt5MOGwNofzDCxqVO6ylSLFDTWXJ7iv18GyeJW+L2fCmSqkUIifUuaG23OP0GneU=&#x27;, &#x27;revoked&#x27;: 0, ...}], &#x27;service&#x27;: []}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC]</td>
          <td class="col-duration">0.52</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#key1&#x27;, &#x27;publ...d&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#resolver&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://www.citln.cn&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:unisot:test:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4]</td>
          <td class="col-duration">0.60</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7f216fc564c0&gt;, did = &#x27;did:unisot:test:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;<br/><br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did):<br/>&gt;       assert await asyncio.wait_for(resolver.resolve(None, did), timeout=30)<br/><br/>int/test_resolution.py:40: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:70: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:149: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7f216ee408e0&gt;, id = &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#key1&#x27;<br/>type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, controller = &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;KmtFiGC5VCbvM3Hk3ibeZxBN5ZDu8cDRR3QRakRaMqxMUUxK7FKx7TSxYLBJ5WNEntFzNTPdNHVssMfDUE3NJo2971&#x27;}, key_type = None<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>            key_type = PublicKeyType.get(type)<br/>            if not key_type:<br/>&gt;               raise ValueError(<br/>                    f&quot;Unexpected key type {type} for verification method &quot;<br/>                    f&quot;{self.serialize()}&quot;<br/>                )<br/><span class="error">E               ValueError: Unexpected key type EcdsaSecp256k1VerificationKey2019 for verification method {&#x27;controller&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, &#x27;id&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#key1&#x27;}</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:67: ValueError<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR]</td>
          <td class="col-duration">0.34</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t]</td>
          <td class="col-duration">0.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud]</td>
          <td class="col-duration">0.31</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:web:did.actor:alice]</td>
          <td class="col-duration">0.29</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:elem:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A]</td>
          <td class="col-duration">2.51</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:github:gjgd]</td>
          <td class="col-duration">0.68</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764]</td>
          <td class="col-duration">1.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6]</td>
          <td class="col-duration">0.17</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB]</td>
          <td class="col-duration">0.16</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH]</td>
          <td class="col-duration">0.16</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:schema:public-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J]</td>
          <td class="col-duration">0.35</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:schema:evan-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J]</td>
          <td class="col-duration">1.57</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7]</td>
          <td class="col-duration">0.86</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody></table></body></html>