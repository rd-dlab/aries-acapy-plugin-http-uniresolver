<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <style>body {
  font-family: Helvetica, Arial, sans-serif;
  font-size: 12px;
  /* do not increase min-width as some may use split screens */
  min-width: 800px;
  color: #999;
}

h1 {
  font-size: 24px;
  color: black;
}

h2 {
  font-size: 16px;
  color: black;
}

p {
  color: black;
}

a {
  color: #999;
}

table {
  border-collapse: collapse;
}

/******************************
 * SUMMARY INFORMATION
 ******************************/
#environment td {
  padding: 5px;
  border: 1px solid #E6E6E6;
}
#environment tr:nth-child(odd) {
  background-color: #f6f6f6;
}

/******************************
 * TEST RESULT COLORS
 ******************************/
span.passed,
.passed .col-result {
  color: green;
}

span.skipped,
span.xfailed,
span.rerun,
.skipped .col-result,
.xfailed .col-result,
.rerun .col-result {
  color: orange;
}

span.error,
span.failed,
span.xpassed,
.error .col-result,
.failed .col-result,
.xpassed .col-result {
  color: red;
}

/******************************
 * RESULTS TABLE
 *
 * 1. Table Layout
 * 2. Extra
 * 3. Sorting items
 *
 ******************************/
/*------------------
 * 1. Table Layout
 *------------------*/
#results-table {
  border: 1px solid #e6e6e6;
  color: #999;
  font-size: 12px;
  width: 100%;
}
#results-table th,
#results-table td {
  padding: 5px;
  border: 1px solid #E6E6E6;
  text-align: left;
}
#results-table th {
  font-weight: bold;
}

/*------------------
 * 2. Extra
 *------------------*/
.log {
  background-color: #e6e6e6;
  border: 1px solid #e6e6e6;
  color: black;
  display: block;
  font-family: "Courier New", Courier, monospace;
  height: 230px;
  overflow-y: scroll;
  padding: 5px;
  white-space: pre-wrap;
}
.log:only-child {
  height: inherit;
}

div.image {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.image img {
  width: 320px;
}

div.video {
  border: 1px solid #e6e6e6;
  float: right;
  height: 240px;
  margin-left: 5px;
  overflow: hidden;
  width: 320px;
}
div.video video {
  overflow: hidden;
  width: 320px;
  height: 240px;
}

.collapsed {
  display: none;
}

.expander::after {
  content: " (show details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

.collapser::after {
  content: " (hide details)";
  color: #BBB;
  font-style: italic;
  cursor: pointer;
}

/*------------------
 * 3. Sorting items
 *------------------*/
.sortable {
  cursor: pointer;
}

.sort-icon {
  font-size: 0px;
  float: left;
  margin-right: 5px;
  margin-top: 5px;
  /*triangle*/
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
}
.inactive .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #E6E6E6;
}
.asc.active .sort-icon {
  /*finish triangle*/
  border-bottom: 8px solid #999;
}
.desc.active .sort-icon {
  /*finish triangle*/
  border-top: 8px solid #999;
}
</style></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>report.html</h1>
    <p>Report generated on 02-Mar-2021 at 22:59:02 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{"pluggy": "0.13.1", "py": "1.10.0", "pytest": "6.2.2"}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Linux-5.10.18-200.fc33.x86_64-x86_64-with-glibc2.32</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{"asyncio": "0.14.0", "html": "3.1.1", "metadata": "1.11.0"}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.9.1</td></tr></table>
    <h2>Summary</h2>
    <p>50 tests ran in 105.68 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">7 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">43 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:xz35-jznz-q9yu-ply]</td>
          <td class="col-duration">3.28</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:btcr:xz35-jznz-q9yu-ply&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40edaebe0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ... &#x27;020a5a5c8c3575489cd2c17d43f642fc2b34792d47c9b026fafe33b3469e31b841&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xz35-jznz-q9yu-ply&#x27;, &#x27;verificationMethod&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xz35-jznz-q9yu-ply#key-0&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;020a5a5c8c3575489cd2c17d43f642fc2b34792d47c9b026fafe33b3469e31b841&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xz35-jznz-q9yu-ply#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;020a5a5c8c3575489cd2c17d43f642fc2b34792d47c9b026fafe33b3469e31b841&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xz35-jznz-q9yu-ply#satoshi&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;020a5a5c8c3575489cd2c17d43f642fc2b34792d47c9b026fafe33b3469e31b841&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:xkrn-xz7q-qsye-28p]</td>
          <td class="col-duration">11.63</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:btcr:xkrn-xz7q-qsye-28p&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e2bad60&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ...79e1bde881c15edc82b7c4d0d04441c5e7f6dce4b703f43c5d5c12948df32d2&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}, ...]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 3: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 4: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 5: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 6: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;https://www.w3.org/ns/did/v1&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p&#x27;, &#x27;verificationMethod&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-0&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;024a63c4362772b0fafc51ac02470dae3f8da8a05d90bae9e1ef3f5243180120dd&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02b5470c5c0557ef7548dec23220d4d75f8c4aa1b459c190f100f4f78a1adb215b&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-2&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02e2078417a258acc2c9f9eb856b35b508d1e5a23fc1dcf94fd6f7337b1cb7fb90&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-3&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02074f9b37f26ae410742ec754b02b3f7d078ff73d7e06b6f7a670d5701805ef82&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-4&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02b4021b6907fbc12b2c0d9278d21bc0f371a56b553fc75eaf75b79d925301f7a4&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#key-5&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;03479e1bde881c15edc82b7c4d0d04441c5e7f6dce4b703f43c5d5c12948df32d2&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:xkrn-xz7q-qsye-28p#satoshi&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;03479e1bde881c15edc82b7c4d0d04441c5e7f6dce4b703f43c5d5c12948df32d2&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:btcr:x705-jznz-q3nl-srs]</td>
          <td class="col-duration">3.16</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:btcr:x705-jznz-q3nl-srs&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e24fee0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}], &#x27;id&#x27;: ... &#x27;02e0e01a8c302976e1556e95c54146e8464adac8626a5d29474718a7281133ff49&#x27;, &#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 1: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}, 2: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;], &#x27;id&#x27;: &#x27;did:btcr:x705-jznz-q3nl-srs&#x27;, &#x27;verificationMethod&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:x705-jznz-q3nl-srs#key-0&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02e0e01a8c302976e1556e95c54146e8464adac8626a5d29474718a7281133ff49&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:x705-jznz-q3nl-srs#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02e0e01a8c302976e1556e95c54146e8464adac8626a5d29474718a7281133ff49&#x27;}, {&#x27;type&#x27;: [&#x27;EcdsaSecp256k1VerificationKey2019&#x27;], &#x27;id&#x27;: &#x27;did:btcr:x705-jznz-q3nl-srs#satoshi&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;02e0e01a8c302976e1556e95c54146e8464adac8626a5d29474718a7281133ff49&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;EcdsaSecp256k1SignatureAuthentication2019&#x27;], &#x27;verificationMethod&#x27;: &#x27;#satoshi&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:sov:WRfXPg8dantKVubE3HX8pw]</td>
          <td class="col-duration">1.02</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:sov:WRfXPg8dantKVubE3HX8pw&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e43f670&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;Ed25519SignatureAuthentication2018&#x27;], &#x27;verificationMethod&#x27;: &#x27;did:sov:WRfXPg8dantKVubE3H...pw#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&#x27;, &#x27;type&#x27;: [&#x27;Ed25519VerificationKey2018&#x27;]}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}, 1: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;verificationMethod&#x27;: {0: {&#x27;controller&#x27;: [&#x27;Missing data for required field.&#x27;], &#x27;type&#x27;: [&#x27;Not a valid string.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;], &#x27;id&#x27;: &#x27;did:sov:WRfXPg8dantKVubE3HX8pw&#x27;, &#x27;verificationMethod&#x27;: [{&#x27;type&#x27;: [&#x27;Ed25519VerificationKey2018&#x27;], &#x27;id&#x27;: &#x27;did:sov:WRfXPg8dantKVubE3HX8pw#key-1&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: [&#x27;Ed25519SignatureAuthentication2018&#x27;], &#x27;verificationMethod&#x27;: &#x27;did:sov:WRfXPg8dantKVubE3HX8pw#key-1&#x27;}], &#x27;service&#x27;: [{&#x27;type&#x27;: [&#x27;agent&#x27;], &#x27;serviceEndpoint&#x27;: &#x27;https://agents.danubeclouds.com/agent/WRfXPg8dantKVubE3HX8pw&#x27;}, {&#x27;type&#x27;: [&#x27;xdi&#x27;], &#x27;serviceEndpoint&#x27;: &#x27;https://xdi03-at.danubeclouds.com/cl/+!:did:sov:WRfXPg8dantKVubE3HX8pw&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E]</td>
          <td class="col-duration">0.55</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e3fadf0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E: Driver reported for did:erc725:ropsten:2F2B37C890824242Cb9B0FE5614fA2221B79901E: Cannot retrieve keys for address 2F2B37C890824242Cb9B0FE5614fA2221B79901E on network ropsten: Cannot look up keys: class java.lang.String cannot be cast to class java.util.List (java.lang.String and java.util.List are in module java.base of loader &#x27;bootstrap&#x27;)</span><br/><br/>http_uniresolver/http_universal.py:79: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm]</td>
          <td class="col-duration">20.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7fe40e339700&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7fe40e1998b0&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7fe40e2f9ee0&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-35&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ipid:QmYA7p467t4BGgBL4NmyHtsXMoPrYH9b3kSG6dbgFYskJm&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e199d90&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-35&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0]</td>
          <td class="col-duration">0.23</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e129a00&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs5...Secp256k1VerificationKey2018&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://core.blockstack.org&#x27;, &#x27;type&#x27;: &#x27;blockstack&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}, &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;, &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;blockstack&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://core.blockstack.org&#x27;}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;publicKeyHex&#x27;: &#x27;040fadbbcea0ff3b05f03195b41cd991d7a0af8bd38559943aec99cbdaf0b22cc806b9a4f07579934774cc0c155e781d45c989f94336765e88a66d91cfb9f060b0&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:web:did.actor:alice]</td>
          <td class="col-duration">0.22</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:web:did.actor:alice&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e30c5e0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e30cb80&gt;<br/>id = &#x27;did:web:did.actor:alice#zC8GybikEfyNaausDA4mkT4egP7SNLx2T1d1kujLQbcP6h&#x27;, type = &#x27;X25519KeyAgreementKey2019&#x27;, controller = &#x27;did:web:did.actor:alice&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;CaSHXEvLKS6SfN9aBfkVGBpp15jSnaHazqHgLHp8KZ3Y&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v0.11&#x27;, &#x27;id&#x27;: &#x27;did:web:did.actor:alice&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:web:did.actor:alice#z6MkrmNwty5ajKtFqc1U48oL2MMLjWjartwc5sf2AihZwXDN&#x27;, &#x27;controller&#x27;: &#x27;did:web:did.actor:alice&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;DK7uJiq9PnPnj7AmNZqVBFoLuwTjT1hFPrk6LSjZ2JRz&#x27;}], &#x27;authentication&#x27;: [&#x27;did:web:did.actor:alice#z6MkrmNwty5ajKtFqc1U48oL2MMLjWjartwc5sf2AihZwXDN&#x27;], &#x27;assertionMethod&#x27;: [&#x27;did:web:did.actor:alice#z6MkrmNwty5ajKtFqc1U48oL2MMLjWjartwc5sf2AihZwXDN&#x27;], &#x27;capabilityDelegation&#x27;: [&#x27;did:web:did.actor:alice#z6MkrmNwty5ajKtFqc1U48oL2MMLjWjartwc5sf2AihZwXDN&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:web:did.actor:alice#z6MkrmNwty5ajKtFqc1U48oL2MMLjWjartwc5sf2AihZwXDN&#x27;], &#x27;keyAgreement&#x27;: [{&#x27;id&#x27;: &#x27;did:web:did.actor:alice#zC8GybikEfyNaausDA4mkT4egP7SNLx2T1d1kujLQbcP6h&#x27;, &#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:web:did.actor:alice&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;CaSHXEvLKS6SfN9aBfkVGBpp15jSnaHazqHgLHp8KZ3Y&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736]</td>
          <td class="col-duration">0.36</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e11c9d0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736#controller&#x27;, &#x27;type&#x27;: &#x27;Secp256k1...ey&#x27;: [&lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e210cd0&gt;]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736#controller&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736&#x27;, &#x27;ethereumAddress&#x27;: &#x27;0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: &#x27;Secp256k1SignatureAuthentication2018&#x27;, &#x27;publicKey&#x27;: &#x27;did:ethr:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736#controller&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e441b20&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:nacl:Md8JiMIwsapml_FtQ2ngnGftNP5UmVCAUuhnLyAsPxI&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: nacl is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[ssi.labs.nic.at]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;ssi.labs.nic.at&#x27;, caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e3a27c0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:65: in resolve<br/>    did = DID(did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DID ssi.labs.nic.at&gt;, did = &#x27;ssi.labs.nic.at&#x27;<br/><br/>    def __init__(self, did: str):<br/>        &quot;&quot;&quot;Validate and parse raw DID str.&quot;&quot;&quot;<br/>        self._raw = did<br/>        matched = DID_PATTERN.fullmatch(did)<br/>        if not matched:<br/>&gt;           raise InvalidDIDError(&quot;Unable to parse DID {}&quot;.format(did))<br/><span class="error">E           aries_cloudagent.resolver.did.InvalidDIDError: Unable to parse DID ssi.labs.nic.at</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/did.py:138: InvalidDIDError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21]</td>
          <td class="col-duration">0.96</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e268130&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21#keys-1&#x27;, ...9dde54242d3b1845d16742d62189c6700b6ab46e24743e9738c04bf5c6c0f2ba208c4ecda65166d3e4563da01fd7f811715cd5fbc3&#x27;, ...}, ...}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;proof&#x27;: [&#x27;Unknown field.&#x27;], &#x27;created&#x27;: [&#x27;Unknown field.&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [{&#x27;id&#x27;: &#x27;@id&#x27;, &#x27;type&#x27;: &#x27;@type&#x27;, &#x27;dc&#x27;: &#x27;http://purl.org/dc/terms/&#x27;, &#x27;rdfs&#x27;: &#x27;http://www.w3.org/2000/01/rdf-schema#&#x27;, &#x27;schema&#x27;: &#x27;http://schema.org/&#x27;, &#x27;sec&#x27;: &#x27;https://w3id.org/security#&#x27;, &#x27;didv&#x27;: &#x27;https://w3id.org/did#&#x27;, &#x27;xsd&#x27;: &#x27;http://www.w3.org/2001/XMLSchema#&#x27;, &#x27;AuthenticationSuite&#x27;: &#x27;sec:AuthenticationSuite&#x27;, &#x27;CryptographicKey&#x27;: &#x27;sec:Key&#x27;, &#x27;LinkedDataSignature2016&#x27;: &#x27;sec:LinkedDataSignature2016&#x27;, &#x27;authentication&#x27;: &#x27;sec:authenticationMethod&#x27;, &#x27;created&#x27;: {&#x27;@id&#x27;: &#x27;dc:created&#x27;, &#x27;@type&#x27;: &#x27;xsd:dateTime&#x27;}, &#x27;creator&#x27;: {&#x27;@id&#x27;: &#x27;dc:creator&#x27;, &#x27;@type&#x27;: &#x27;@id&#x27;}, &#x27;digestAlgorithm&#x27;: &#x27;sec:digestAlgorithm&#x27;, &#x27;digestValue&#x27;: &#x27;sec:digestValue&#x27;, &#x27;domain&#x27;: &#x27;sec:domain&#x27;, &#x27;entity&#x27;: &#x27;sec:entity&#x27;, &#x27;expires&#x27;: {&#x27;@id&#x27;: &#x27;sec:expiration&#x27;, &#x27;@type&#x27;: &#x27;xsd:dateTime&#x27;}, &#x27;name&#x27;: &#x27;schema:name&#x27;, &#x27;nonce&#x27;: &#x27;sec:nonce&#x27;, &#x27;normalizationAlgorithm&#x27;: &#x27;sec:normalizationAlgorithm&#x27;, &#x27;owner&#x27;: {&#x27;@id&#x27;: &#x27;sec:owner&#x27;, &#x27;@type&#x27;: &#x27;@id&#x27;}, &#x27;privateKey&#x27;: {&#x27;@id&#x27;: &#x27;sec:privateKey&#x27;, &#x27;@type&#x27;: &#x27;@id&#x27;}, &#x27;proof&#x27;: &#x27;sec:proof&#x27;, &#x27;proofAlgorithm&#x27;: &#x27;sec:proofAlgorithm&#x27;, &#x27;proofType&#x27;: &#x27;sec:proofType&#x27;, &#x27;proofValue&#x27;: &#x27;sec:proofValue&#x27;, &#x27;publicKey&#x27;: {&#x27;@id&#x27;: &#x27;sec:publicKey&#x27;, &#x27;@type&#x27;: &#x27;@id&#x27;, &#x27;@container&#x27;: &#x27;@set&#x27;}, &#x27;requiredProof&#x27;: &#x27;sec:requiredProof&#x27;, &#x27;revoked&#x27;: {&#x27;@id&#x27;: &#x27;sec:revoked&#x27;, &#x27;@type&#x27;: &#x27;xsd:dateTime&#x27;}, &#x27;signature&#x27;: &#x27;sec:signature&#x27;, &#x27;signatureAlgorithm&#x27;: &#x27;sec:signatureAlgorithm&#x27;, &#x27;signatureValue&#x27;: &#x27;sec:signatureValue&#x27;}], &#x27;id&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21&#x27;, &#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21#keys-1&#x27;, &#x27;type&#x27;: &#x27;Secp256k1SignatureAuthentication2018&#x27;}], &#x27;publicKey&#x27;: [{&#x27;owner&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21&#x27;, &#x27;id&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21#keys-1&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0339f4a432a16ecc733f973af36417f5634f3d8a9195edcb668933a2cb7a988a37&#x27;}], &#x27;service&#x27;: [], &#x27;created&#x27;: &#x27;2019-01-17T16:49:32.018Z&#x27;, &#x27;proof&#x27;: {&#x27;created&#x27;: &#x27;2019-01-17T16:49:32.018Z&#x27;, &#x27;type&#x27;: &#x27;EcdsaKoblitzSignature2016&#x27;, &#x27;nonce&#x27;: &#x27;cbc71953e0db2f26&#x27;, &#x27;signatureValue&#x27;: &#x27;68b5f47631ba121b840b169dde54242d3b1845d16742d62189c6700b6ab46e24743e9738c04bf5c6c0f2ba208c4ecda65166d3e4563da01fd7f811715cd5fbc3&#x27;, &#x27;creator&#x27;: &#x27;did:jolo:e76fb4b4900e43891f613066b9afca366c6d22f7d87fc9f78a91515be24dfb21#keys-1&#x27;}}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e3ca4f0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:hcr:0f674e7e-4b49-4898-85f6-96176c1e30de&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: hcr is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:elem:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A]</td>
          <td class="col-duration">2.66</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:elem:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e2ad1f0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e21a4f0&gt;<br/>id = &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#keyAgreement&#x27;, type = &#x27;X25519KeyAgreementKey2019&#x27;<br/>controller = &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;ENpfk9K9J6uss5qu6BrAszioE732mYCobmMPSpvB3faM&#x27;, &#x27;usage&#x27;: &#x27;signing&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;keyAgreement&#x27;: [{&#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;ENpfk9K9J6uss5qu6BrAszioE732mYCobmMPSpvB3faM&#x27;, &#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#keyAgreement&#x27;, &#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}], &#x27;authentication&#x27;: [&#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#edv&#x27;, {&#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#authentication&#x27;, &#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}], &#x27;publicKey&#x27;: [{&#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#primary&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0361f286ada2a6b2c74bc6ed44a71ef59fb9dd15eca9283cbe5608aeb516730f33&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}, {&#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#recovery&#x27;, &#x27;publicKeyHex&#x27;: &#x27;02c00982681081372cbb941cd2c9745908316e1373ac333479f0deabcad0e9d574&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;usage&#x27;: &#x27;recovery&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}, {&#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#edv&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;atEBuHypSkQx7486xT5FUkoBLqvNcWyNK2Xz9EPjdMy&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}, {&#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#delegate&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey2018&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY\nMIIBCgKCAQEAvzoCEC2rpSpJQaWZbUmlsDNwp83Jr4fi6KmBWIwnj1MZ6CUQ7rBa\nsuLI8AcfX5/10scSfQNCsTLV2tMKQaHuvyrVfwY0dINk+nkqB74QcT2oCCH9XduJ\njDuwWA4xLqAKuF96FsIes52opEM50W7/W7DZCKXkC8fFPFj6QF5ZzApDw2Qsu3yM\nRmr7/W9uWeaTwfPx24YdY7Ah+fdLy3KN40vXv9c4xiSafVvnx9BwYL7H1Q8NiK9L\nGEN6+JSWfgckQCs6UUBOXSZdreNN9zbQCwyzee7bOJqXUDAuLcFARzPw1EsZAyjV\ntGCKIQ0/btqK+jFunT2NBC8RItanDZpptQIDAQAB\nEND PUBLIC KEY-----\r\n&#x27;, &#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}, {&#x27;usage&#x27;: &#x27;signing&#x27;, &#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#key-JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw&#x27;, &#x27;publicKeyJwk&#x27;: {&#x27;x&#x27;: &#x27;dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A&#x27;, &#x27;kid&#x27;: &#x27;JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw&#x27;, &#x27;crv&#x27;: &#x27;secp256k1&#x27;, &#x27;kty&#x27;: &#x27;EC&#x27;, &#x27;y&#x27;: &#x27;36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA&#x27;}, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}], &#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#openid&#x27;, &#x27;type&#x27;: &#x27;OpenIdConnectVersion1.0Service&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/&#x27;}], &#x27;assertionMethod&#x27;: [&#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#edv&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#edv&#x27;], &#x27;capabilityDelegation&#x27;: [&#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A#edv&#x27;], &#x27;id&#x27;: &#x27;did:elem:ropsten:EiAS3mqC4OLMKOwcz3ItIL7XfWduPT7q3Fa4vHgiCfSG2A&#x27;}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:github:gjgd]</td>
          <td class="col-duration">0.75</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:github:gjgd&#x27;, caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e192b20&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e29cac0&gt;, id = &#x27;did:github:gjgd#nj-UQm3dz5BpX5UX4f2aMB2F39PQSO10ROVWnYpWSj4&#x27;<br/>type = &#x27;OpenPgpVerificationKey2019&#x27;, controller = &#x27;did:github:gjgd&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PGP PUBLIC KEY BLOCK-----\r\nVersion: OpenPGP.js v4.10.4\r\nComment: https://openpgpjs.or...IA9uuaT/CHiYPxAQC1GVFg/HsSCikeSmOV/Te0kb60G13+ffln\r\n9EQnBMQJbw==\r\n=2eMS\r\n-----END PGP PUBLIC KEY BLOCK-----\r\n&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:github:gjgd&#x27;, &#x27;publicKey&#x27;: [{&#x27;type&#x27;: &#x27;OpenPgpVerificationKey2019&#x27;, &#x27;id&#x27;: &#x27;did:github:gjgd#nj-UQm3dz5BpX5UX4f2aMB2F39PQSO10ROVWnYpWSj4&#x27;, &#x27;controller&#x27;: &#x27;did:github:gjgd&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PGP PUBLIC KEY BLOCK-----\r\nVersion: OpenPGP.js v4.10.4\r\nComment: https://openpgpjs.org\r\n\r\nxk8EXqh2+xMFK4EEAAoCAwR2PP0CM6D9mHe7/U8uTM3jYbFz5AplyZE43Jm1\r\nVdpxP9gewWZYu3mgWkM84Xz02XtrXIz6JlUKqQoR+0c7d1iYzRdhbm9uIDxh\r\nbm9uQGV4YW1wbGUuY29tPsJ4BBATCAAgBQJeqHb7BgsJBwgDAgQVCAoCBBYC\r\nAQACGQECGwMCHgEACgkQ8mYJ+2/BPYwZqAD/ctdWEx0vLwdYOHrFBW7QgTXI\r\nVsRm2H9peVrb+iDc27oA/1hFGrK+jgL3lgQPoWo0AdAnOiQnhVCQ+B9JQ9Nt\r\n2ZCYzlMEXqh2+xIFK4EEAAoCAwSG/xVTu5u65hTvct5cPJd5EGE4neuZZMfk\r\nTJVp++Ep/4hZ0bZaCyHvZUS3BBGjZW7oyvUTrFAZtWnNNtdtir3jAwEIB8Jh\r\nBBgTCAAJBQJeqHb7AhsMAAoJEPJmCftvwT2MppMBALP+AZaFPtGiEKJ42Wdy\r\nn0kWrnfgk6IA9uuaT/CHiYPxAQC1GVFg/HsSCikeSmOV/Te0kb60G13+ffln\r\n9EQnBMQJbw==\r\n=2eMS\r\n-----END PGP PUBLIC KEY BLOCK-----\r\n&#x27;}, {&#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;id&#x27;: &#x27;did:github:gjgd#edQPY-F4N3AOBWb7T3VPiY9zJ7VxdKmPG6cB8KV0a94&#x27;, &#x27;controller&#x27;: &#x27;did:github:gjgd&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;CLEipQaDBbt91GAxHHujpQ7mes485QqRcGT3cannTQLM&#x27;}], &#x27;authentication&#x27;: [], &#x27;service&#x27;: [], &#x27;capabilityDelegation&#x27;: [&#x27;did:github:gjgd#edQPY-F4N3AOBWb7T3VPiY9zJ7VxdKmPG6cB8KV0a94&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:github:gjgd#edQPY-F4N3AOBWb7T3VPiY9zJ7VxdKmPG6cB8KV0a94&#x27;], &#x27;assertionMethod&#x27;: [&#x27;did:github:gjgd#edQPY-F4N3AOBWb7T3VPiY9zJ7VxdKmPG6cB8KV0a94&#x27;], &#x27;keyAgreement&#x27;: [{&#x27;id&#x27;: &#x27;did:github:gjgd#zC1sYUy6Xo4WgLErBG1koqeGzMV8R3JsbcrLxAcGVkyQ9x&#x27;, &#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:github:gjgd&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;2NpmbuibgmPu8oCocGEsV7K4Erc5kAz7xTf8mBhMsA3k&#x27;}], &#x27;proof&#x27;: {&#x27;type&#x27;: &#x27;Ed25519Signature2018&#x27;, &#x27;created&#x27;: &#x27;2020-05-04T17:00:14Z&#x27;, &#x27;verificationMethod&#x27;: &#x27;did:github:gjgd#edQPY-F4N3AOBWb7T3VPiY9zJ7VxdKmPG6cB8KV0a94&#x27;, &#x27;proofPurpose&#x27;: &#x27;assertionMethod&#x27;, &#x27;jws&#x27;: &#x27;eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..t57scngjBf7TBPC7HGIlsaXbOzKcAHhAS5elPsopia2dqiX_6D1drePTmdIz4aeyTWotFyInYYWdMinToIGtCA&#x27;}}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e29d040&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:neoid:priv:b4eeeb80d20bfb38b23001d0659ce0c1d96be0aa&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: neoid is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw]</td>
          <td class="col-duration">1.38</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e0e79d0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw#key-1&#x27;], &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;id&#x27;: &#x27;did:ccp...f1cd4944dfb93&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw&#x27;, &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;DIDResolve&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKey&#x27;: [&#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw#key-1&#x27;]}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw#key-1&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKeyHex&#x27;: &#x27;046fcbedd1107ca45be3e81fc445e5a366886a89e7087fe3d128e6236302f31594740f250433ebe9f0abcbd04dbf9c5979e270a0772ad1cc502cec2d5de9504c8c&#x27;}, {&#x27;id&#x27;: &#x27;did:ccp:ceNobbK6Me9F5zwyE3MKY88QZLw#key-2&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0496712d16b0836684aacd5ab6ba3d489c35efa31f414a1c6a455fc6b37ff28e5fa97ac29c1021b76e5b78e2bbceac1dfc4ec98e6b2b3e65a29f7f1cd4944dfb93&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd]</td>
          <td class="col-duration">0.45</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e3905b0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd#key-1&#x27;], &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;id&#x27;: &#x27;did:cc...843931c877e7f&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;}], &#x27;service&#x27;: [{&#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd&#x27;, &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;DIDResolve&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://did.baidu.com&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKey&#x27;: [&#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd#key-1&#x27;]}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd#key-1&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0440b3fa8e848297ff26b04088263101fa87d3541ac48bbc32fe7b77b73246578241236ab6097d4012ac17a514272a54a7b728790e914bbbff431e49d421aa1eef&#x27;}, {&#x27;id&#x27;: &#x27;did:ccp:3CzQLF3qfFVQ1CjGVzVRZaFXrjAd#key-2&#x27;, &#x27;type&#x27;: &#x27;Secp256k1&#x27;, &#x27;publicKeyHex&#x27;: &#x27;04df4cf82984c9ecd4cf113e24762fb4404c1653df84ac424e4e2985ba7eb4de9249c2609414a24feea7845649299049b4babd6380ee69ef9e91c843931c877e7f&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:work:2UUHQCd4psvkPLZGnWY33L]</td>
          <td class="col-duration">0.58</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:work:2UUHQCd4psvkPLZGnWY33L&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40ed1caf0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:work:2UUHQCd4psvkPLZGnWY33L&#x27;, &#x27;publicKey&#x27;: [&lt;aries_cloudagent.connections.models.diddoc_v2.verification_me...ceEndpoint&#x27;: &#x27;did:work:8RcWPSBtB4QwfC68yneDxC;id=860285e2-183d-4fe3-9767-babc744396b8;version=1.0&#x27;, &#x27;type&#x27;: &#x27;schema&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:work:2UUHQCd4psvkPLZGnWY33L&#x27;, &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;schema&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;did:work:8RcWPSBtB4QwfC68yneDxC;id=860285e2-183d-4fe3-9767-babc744396b8;version=1.0&#x27;}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:work:2UUHQCd4psvkPLZGnWY33L#key-1&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:work:4PUfQhXdyRY4LLNkKUs16S&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;oatUtA5A97kQ7mWYK8qHkVFvJKtnhRdBZPSwuC3dADw&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH]</td>
          <td class="col-duration">0.33</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1b90a0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e2a8b80&gt;, id = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH#keys-1&#x27;<br/>type = &#x27;EcdsaSecp256r1VerificationKey2019&#x27;, controller = &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;023b041dfc2d00a9846d291dd4bad3f32b8c13a6ad8dc2e97fd711888ed7818c66&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;, &#x27;authentication&#x27;: [&#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH#keys-1&#x27;], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH#keys-1&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256r1VerificationKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:ont:AN5g6gz9EoQ3sCNu7514GEghZurrktCMiH&#x27;, &#x27;publicKeyHex&#x27;: &#x27;023b041dfc2d00a9846d291dd4bad3f32b8c13a6ad8dc2e97fd711888ed7818c66&#x27;}], &#x27;controller&#x27;: &#x27;&#x27;, &#x27;recovery&#x27;: &#x27;&#x27;}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx]</td>
          <td class="col-duration">0.71</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e21a250&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e1f34c0&gt;, id = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-2&#x27;<br/>type = &#x27;X25519Salsa20Poly1305Key2018&#x27;, controller = &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;0xd0a90ed3b87db1ab599bd3cc0c8e0dc7ffcf2347299a6d494567a14f06861952&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;id&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, &#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;authentication&#x27;: [{&#x27;type&#x27;: &#x27;Ed25519SignatureAuthentication2018&#x27;, &#x27;publicKey&#x27;: [&#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-1&#x27;]}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-1&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0x2203a7731f1e4362cb21ff3ef7ce79204e1891fc62c4657040753283a00300d8&#x27;}, {&#x27;id&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx#key-2&#x27;, &#x27;type&#x27;: &#x27;X25519Salsa20Poly1305Key2018&#x27;, &#x27;controller&#x27;: &#x27;did:kilt:5CqJa4Ct7oMeMESzehTiN9fwYdGLd7tqeirRMpGDh2XxYYyx&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0xd0a90ed3b87db1ab599bd3cc0c8e0dc7ffcf2347299a6d494567a14f06861952&#x27;}], &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;KiltMessagingService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://services.kilt.io:443/messaging&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734]</td>
          <td class="col-duration">0.80</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1b95e0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [&#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734#key-1&#x27;], &#x27;id&#x27;: &#x27;did:evan:testcore:0x...60fd734#randomService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/770853367&#x27;, &#x27;type&#x27;: &#x27;randomService-770853367&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734#key-1&#x27;, &#x27;type&#x27;: [&#x27;Secp256k1SignatureVerificationKey2018&#x27;, &#x27;ERC725ManagementKey&#x27;], &#x27;publicKeyHex&#x27;: &#x27;045adfd502c0bc55f4fcb90eea36368d7e19c5b3045aa6f51dfa3699046e9751251d21bc6bdd06c1ff0014fcbbf9f1d83c714434f2b33d713aaf46760f2d53f10d&#x27;}], &#x27;authentication&#x27;: [&#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734#key-1&#x27;], &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:evan:testcore:0x126E901F6F408f5E260d95c62E7c73D9B60fd734#randomService&#x27;, &#x27;type&#x27;: &#x27;randomService-770853367&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/770853367&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:echo:1.1.25.0]</td>
          <td class="col-duration">0.19</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:echo:1.1.25.0&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e0ceb50&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:echo:1.1.25.0&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:echo:1.1.25.0: Driver reported for did:echo:1.1.25.0: IO exception! Can be invalid json response! testnet.echo-dev.io</span><br/><br/>http_uniresolver/http_universal.py:79: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6]</td>
          <td class="col-duration">0.17</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e11c730&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e169c70&gt;<br/>id = &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6LSbgq3GejX88eiAYWmZ9EiddS3GaXodvm8MJJyEH7bqXgz&#x27;, type = &#x27;X25519KeyAgreementKey2019&#x27;<br/>controller = &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;, value = None, authn = False, kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;1eskLvf2fvy5A912VimK3DZRRzgwKayUKbHjpU589vE&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;], &#x27;id&#x27;: &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;2QTnR7atrFu3Y7S6Xmmr4hTsMaL1KDh6Mpe9MgnJugbi&#x27;}], &#x27;authentication&#x27;: [&#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;], &#x27;assertionMethod&#x27;: [&#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;], &#x27;capabilityDelegation&#x27;: [&#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;], &#x27;keyAgreement&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6#z6LSbgq3GejX88eiAYWmZ9EiddS3GaXodvm8MJJyEH7bqXgz&#x27;, &#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6Mkfriq1MqLBoPWecGoDLjguo1sB9brj6wT3qZ5BxkKpuP6&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;1eskLvf2fvy5A912VimK3DZRRzgwKayUKbHjpU589vE&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB]</td>
          <td class="col-duration">0.18</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1cc0a0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e1e30d0&gt;<br/>id = &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6LSnGSYfMeexNAjfQk4GrZwPGwGYErZ5PRBvd4FfJu4aGzs&#x27;, type = &#x27;X25519KeyAgreementKey2019&#x27;<br/>controller = &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;, value = None, authn = False, kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;BbGP93qnruSza2NHkD3z4ginh6KSNnF33eLaArFXruE7&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;], &#x27;id&#x27;: &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;Dwn2aqMWDfvMwuVD1qYBbpYdoGfpeWbFkEkAHYffwfwo&#x27;}], &#x27;authentication&#x27;: [&#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;], &#x27;assertionMethod&#x27;: [&#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;], &#x27;capabilityDelegation&#x27;: [&#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;], &#x27;keyAgreement&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB#z6LSnGSYfMeexNAjfQk4GrZwPGwGYErZ5PRBvd4FfJu4aGzs&#x27;, &#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6MksQ35B5bwZDQq4QKuhQW2Sv6dcqwg4PqcSFf67pdgrtjB&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;BbGP93qnruSza2NHkD3z4ginh6KSNnF33eLaArFXruE7&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH]</td>
          <td class="col-duration">0.16</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e43f7f0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e1c1040&gt;<br/>id = &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6LSbysY2xFMRpGMhb7tFTLMpeuPRaqaWM1yECx2AtzE3KCc&#x27;, type = &#x27;X25519KeyAgreementKey2019&#x27;<br/>controller = &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;, value = None, authn = False, kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;JhNWeSVLMYccCk7iopQW4guaSJTojqpMEELgSLhKwRr&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;], &#x27;id&#x27;: &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;B12NYF8RrR3h41TDCTJojY59usg3mbtbjnFs7Eud1Y6u&#x27;}], &#x27;authentication&#x27;: [&#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;], &#x27;assertionMethod&#x27;: [&#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;], &#x27;capabilityDelegation&#x27;: [&#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;], &#x27;capabilityInvocation&#x27;: [&#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;], &#x27;keyAgreement&#x27;: [{&#x27;id&#x27;: &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH#z6LSbysY2xFMRpGMhb7tFTLMpeuPRaqaWM1yECx2AtzE3KCc&#x27;, &#x27;type&#x27;: &#x27;X25519KeyAgreementKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;JhNWeSVLMYccCk7iopQW4guaSJTojqpMEELgSLhKwRr&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p]</td>
          <td class="col-duration">0.18</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e0e7550&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p: Cannot retrieve RESOLVE RESULT for did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p from http://dock-did-driver:8080/1.0/identifiers/did:dock:5FXqofpV7dsuki925U1dSzDvBuQbaci5yWTQGVWRQ7bdQP5p: Connect to dock-did-driver:8080 [dock-did-driver/10.100.68.233] failed: Connection refused (Connection refused)</span><br/><br/>http_uniresolver/http_universal.py:79: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE]</td>
          <td class="col-duration">0.27</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e00ca90&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE#owner&#x27;], &#x27;type&#x27;: &#x27;Ed25519SignatureAut...btnetwork.io&#x27;, &#x27;type&#x27;: &#x27;DIDResolver&#x27;}, {&#x27;serviceEndpoint&#x27;: &#x27;https://explorer.abtnetwork.io&#x27;, &#x27;type&#x27;: &#x27;BlockExplorer&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;service&#x27;: {0: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}, 1: {&#x27;id&#x27;: [&#x27;Missing data for required field.&#x27;]}}, &#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE&#x27;, &#x27;service&#x27;: [{&#x27;type&#x27;: &#x27;DIDResolver&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://did.abtnetwork.io&#x27;}, {&#x27;type&#x27;: &#x27;BlockExplorer&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://explorer.abtnetwork.io&#x27;}], &#x27;authentication&#x27;: [{&#x27;type&#x27;: &#x27;Ed25519SignatureAuthentication2018&#x27;, &#x27;publicKey&#x27;: [&#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE#owner&#x27;]}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE#owner&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;owner&#x27;: &#x27;did:abt:z11MVbRGLFt6RXaHzX7Xj7rmHfeiyFkJiiRE&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1b9cd0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None<br/>did = &lt;DID did:trustbloc:testnet.trustbloc.dev:EiBLTZcCj6u_XsufSuLVh2zbPEREjDcu8bnPgs0XyKkfPQ&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: trustbloc is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e21f790&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:sirius:2VhYrbauc2cCx9ZpCp5wrDtK7HKf7jrsvgoKBD4KgK&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: sirius is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg]</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1ed250&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:mpg:7PGGnRdvKKFftSXU3Jw75Vk5npfg&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>&gt;           raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/><span class="error">E           aries_cloudagent.resolver.base.DIDMethodNotSupported: mpg is not supported by HTTPUniversalDIDResolver resolver.</span><br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:68: DIDMethodNotSupported<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ]</td>
          <td class="col-duration">20.02</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7fe40e186ec0&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7fe40e275d30&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7fe40e3c5640&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-129&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:trust:cert.EiBJ6qjVXgJ-A8xnaUiu4rtLDgeobQYgRWjMV49aCak4HQ&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e275700&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-129&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA]</td>
          <td class="col-duration">20.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, profile = None, did = &lt;DID did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&gt;<br/><br/>    async def resolve(self, profile: Profile, did: Union[str, DID]) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve a DID using this resolver.&quot;&quot;&quot;<br/>        if isinstance(did, str):<br/>            did = DID(did)<br/>    <br/>        if not self.supports(did.method):<br/>            raise DIDMethodNotSupported(<br/>                f&quot;{did.method} is not supported by {self.__class__.__name__} resolver.&quot;<br/>            )<br/>&gt;       return await self._resolve(profile, did)<br/><br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>&gt;           async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/><br/>http_uniresolver/http_universal.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client._RequestContextManager object at 0x7fe40e3ef880&gt;<br/><br/>    async def __aenter__(self) -&gt; _RetType:<br/>&gt;       self._resp = await self._coro<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:1012: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client.ClientSession object at 0x7fe40e07c8e0&gt;, method = &#x27;GET&#x27;<br/>str_or_url = &#x27;https://dev.uniresolver.io/1.0/identifiers/did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&#x27;<br/><br/>    async def _request(<br/>            self,<br/>            method: str,<br/>            str_or_url: StrOrURL, *,<br/>            params: Optional[Mapping[str, str]]=None,<br/>            data: Any=None,<br/>            json: Any=None,<br/>            cookies: Optional[LooseCookies]=None,<br/>            headers: LooseHeaders=None,<br/>            skip_auto_headers: Optional[Iterable[str]]=None,<br/>            auth: Optional[BasicAuth]=None,<br/>            allow_redirects: bool=True,<br/>            max_redirects: int=10,<br/>            compress: Optional[str]=None,<br/>            chunked: Optional[bool]=None,<br/>            expect100: bool=False,<br/>            raise_for_status: Optional[bool]=None,<br/>            read_until_eof: bool=True,<br/>            proxy: Optional[StrOrURL]=None,<br/>            proxy_auth: Optional[BasicAuth]=None,<br/>            timeout: Union[ClientTimeout, object]=sentinel,<br/>            verify_ssl: Optional[bool]=None,<br/>            fingerprint: Optional[bytes]=None,<br/>            ssl_context: Optional[SSLContext]=None,<br/>            ssl: Optional[Union[SSLContext, bool, Fingerprint]]=None,<br/>            proxy_headers: Optional[LooseHeaders]=None,<br/>            trace_request_ctx: Optional[SimpleNamespace]=None<br/>    ) -&gt; ClientResponse:<br/>    <br/>        # NOTE: timeout clamps existing connect and read timeouts.  We cannot<br/>        # set the default to None because we need to detect if the user wants<br/>        # to use the existing timeouts by setting timeout to None.<br/>    <br/>        if self.closed:<br/>            raise RuntimeError(&#x27;Session is closed&#x27;)<br/>    <br/>        ssl = _merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)<br/>    <br/>        if data is not None and json is not None:<br/>            raise ValueError(<br/>                &#x27;data and json parameters can not be used at the same time&#x27;)<br/>        elif json is not None:<br/>            data = payload.JsonPayload(json, dumps=self._json_serialize)<br/>    <br/>        if not isinstance(chunked, bool) and chunked is not None:<br/>            warnings.warn(<br/>                &#x27;Chunk size is deprecated #1615&#x27;, DeprecationWarning)<br/>    <br/>        redirects = 0<br/>        history = []<br/>        version = self._version<br/>    <br/>        # Merge with default headers and transform to CIMultiDict<br/>        headers = self._prepare_headers(headers)<br/>        proxy_headers = self._prepare_headers(proxy_headers)<br/>    <br/>        try:<br/>            url = URL(str_or_url)<br/>        except ValueError:<br/>            raise InvalidURL(str_or_url)<br/>    <br/>        skip_headers = set(self._skip_auto_headers)<br/>        if skip_auto_headers is not None:<br/>            for i in skip_auto_headers:<br/>                skip_headers.add(istr(i))<br/>    <br/>        if proxy is not None:<br/>            try:<br/>                proxy = URL(proxy)<br/>            except ValueError:<br/>                raise InvalidURL(proxy)<br/>    <br/>        if timeout is sentinel:<br/>            real_timeout = self._timeout  # type: ClientTimeout<br/>        else:<br/>            if not isinstance(timeout, ClientTimeout):<br/>                real_timeout = ClientTimeout(total=timeout)  # type: ignore<br/>            else:<br/>                real_timeout = timeout<br/>        # timeout is cumulative for all request operations<br/>        # (request, redirects, responses, data consuming)<br/>        tm = TimeoutHandle(self._loop, real_timeout.total)<br/>        handle = tm.start()<br/>    <br/>        traces = [<br/>            Trace(<br/>                self,<br/>                trace_config,<br/>                trace_config.trace_config_ctx(<br/>                    trace_request_ctx=trace_request_ctx)<br/>            )<br/>            for trace_config in self._trace_configs<br/>        ]<br/>    <br/>        for trace in traces:<br/>            await trace.send_request_start(<br/>                method,<br/>                url,<br/>                headers<br/>            )<br/>    <br/>        timer = tm.timer()<br/>        try:<br/>            with timer:<br/>                while True:<br/>                    url, auth_from_url = strip_auth_from_url(url)<br/>                    if auth and auth_from_url:<br/>                        raise ValueError(&quot;Cannot combine AUTH argument with &quot;<br/>                                         &quot;credentials encoded in URL&quot;)<br/>    <br/>                    if auth is None:<br/>                        auth = auth_from_url<br/>                    if auth is None:<br/>                        auth = self._default_auth<br/>                    # It would be confusing if we support explicit<br/>                    # Authorization header with auth argument<br/>                    if (headers is not None and<br/>                            auth is not None and<br/>                            hdrs.AUTHORIZATION in headers):<br/>                        raise ValueError(&quot;Cannot combine AUTHORIZATION header &quot;<br/>                                         &quot;with AUTH argument or credentials &quot;<br/>                                         &quot;encoded in URL&quot;)<br/>    <br/>                    all_cookies = self._cookie_jar.filter_cookies(url)<br/>    <br/>                    if cookies is not None:<br/>                        tmp_cookie_jar = CookieJar()<br/>                        tmp_cookie_jar.update_cookies(cookies)<br/>                        req_cookies = tmp_cookie_jar.filter_cookies(url)<br/>                        if req_cookies:<br/>                            all_cookies.load(req_cookies)<br/>    <br/>                    if proxy is not None:<br/>                        proxy = URL(proxy)<br/>                    elif self._trust_env:<br/>                        for scheme, proxy_info in proxies_from_env().items():<br/>                            if scheme == url.scheme:<br/>                                proxy = proxy_info.proxy<br/>                                proxy_auth = proxy_info.proxy_auth<br/>                                break<br/>    <br/>                    req = self._request_class(<br/>                        method, url, params=params, headers=headers,<br/>                        skip_auto_headers=skip_headers, data=data,<br/>                        cookies=all_cookies, auth=auth, version=version,<br/>                        compress=compress, chunked=chunked,<br/>                        expect100=expect100, loop=self._loop,<br/>                        response_class=self._response_class,<br/>                        proxy=proxy, proxy_auth=proxy_auth, timer=timer,<br/>                        session=self,<br/>                        ssl=ssl, proxy_headers=proxy_headers, traces=traces)<br/>    <br/>                    # connection timeout<br/>                    try:<br/>                        with CeilTimeout(real_timeout.connect,<br/>                                         loop=self._loop):<br/>                            assert self._connector is not None<br/>                            conn = await self._connector.connect(<br/>                                req,<br/>                                traces=traces,<br/>                                timeout=real_timeout<br/>                            )<br/>                    except asyncio.TimeoutError as exc:<br/>                        raise ServerTimeoutError(<br/>                            &#x27;Connection timeout &#x27;<br/>                            &#x27;to host {0}&#x27;.format(url)) from exc<br/>    <br/>                    assert conn.transport is not None<br/>    <br/>                    assert conn.protocol is not None<br/>                    conn.protocol.set_response_params(<br/>                        timer=timer,<br/>                        skip_payload=method.upper() == &#x27;HEAD&#x27;,<br/>                        read_until_eof=read_until_eof,<br/>                        auto_decompress=self._auto_decompress,<br/>                        read_timeout=real_timeout.sock_read)<br/>    <br/>                    try:<br/>                        try:<br/>                            resp = await req.send(conn)<br/>                            try:<br/>&gt;                               await resp.start(conn)<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client.py:504: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;ClientResponse(https://dev.uniresolver.io/1.0/identifiers/did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA) [None None]&gt;<br/>None<br/><br/>connection = Connection&lt;ConnectionKey(host=&#x27;dev.uniresolver.io&#x27;, port=443, is_ssl=True, ssl=None, proxy=None, proxy_auth=None, proxy_headers_hash=None)&gt;<br/><br/>    async def start(self, connection: &#x27;Connection&#x27;) -&gt; &#x27;ClientResponse&#x27;:<br/>        &quot;&quot;&quot;Start response processing.&quot;&quot;&quot;<br/>        self._closed = False<br/>        self._protocol = connection.protocol<br/>        self._connection = connection<br/>    <br/>        with self._timer:<br/>            while True:<br/>                # read response<br/>                try:<br/>&gt;                   message, payload = await self._protocol.read()  # type: ignore  # noqa<br/><br/>env/lib64/python3.9/site-packages/aiohttp/client_reqrep.py:847: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aiohttp.client_proto.ResponseHandler object at 0x7fe40e391100&gt;<br/><br/>    async def read(self) -&gt; _T:<br/>        if not self._buffer and not self._eof:<br/>            assert not self._waiter<br/>            self._waiter = self._loop.create_future()<br/>            try:<br/>&gt;               await self._waiter<br/><span class="error">E               asyncio.exceptions.CancelledError</span><br/><br/>env/lib64/python3.9/site-packages/aiohttp/streams.py:591: CancelledError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>fut = &lt;Task cancelled name=&#x27;Task-133&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>&gt;                   fut.result()<br/><span class="error">E                   asyncio.exceptions.CancelledError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:489: CancelledError<br/><br/>The above exception was the direct cause of the following exception:<br/><br/>resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:trust:licence.EiAMIYqz-ZlmFMrH6GqADqZThYmgV-x38Zwcjl6WR9qGhA&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e390460&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fut = &lt;Task cancelled name=&#x27;Task-133&#x27; coro=&lt;BaseDIDResolver.resolve() done, defined at /home/dbluhm/dev/aries/cloudagent-python/aries_cloudagent/resolver/base.py:62&gt;&gt;, timeout = 20<br/><br/>    async def wait_for(fut, timeout, *, loop=None):<br/>        &quot;&quot;&quot;Wait for the single Future or coroutine to complete, with timeout.<br/>    <br/>        Coroutine will be wrapped in Task.<br/>    <br/>        Returns result of the Future or coroutine.  When a timeout occurs,<br/>        it cancels the task and raises TimeoutError.  To avoid the task<br/>        cancellation, wrap it in shield().<br/>    <br/>        If the wait is cancelled, the task is also cancelled.<br/>    <br/>        This function is a coroutine.<br/>        &quot;&quot;&quot;<br/>        if loop is None:<br/>            loop = events.get_running_loop()<br/>        else:<br/>            warnings.warn(&quot;The loop argument is deprecated since Python 3.8, &quot;<br/>                          &quot;and scheduled for removal in Python 3.10.&quot;,<br/>                          DeprecationWarning, stacklevel=2)<br/>    <br/>        if timeout is None:<br/>            return await fut<br/>    <br/>        if timeout &lt;= 0:<br/>            fut = ensure_future(fut, loop=loop)<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>    <br/>            await _cancel_and_wait(fut, loop=loop)<br/>            try:<br/>                fut.result()<br/>            except exceptions.CancelledError as exc:<br/>                raise exceptions.TimeoutError() from exc<br/>            else:<br/>                raise exceptions.TimeoutError()<br/>    <br/>        waiter = loop.create_future()<br/>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br/>        cb = functools.partial(_release_waiter, waiter)<br/>    <br/>        fut = ensure_future(fut, loop=loop)<br/>        fut.add_done_callback(cb)<br/>    <br/>        try:<br/>            # wait until the future completes or the timeout<br/>            try:<br/>                await waiter<br/>            except exceptions.CancelledError:<br/>                if fut.done():<br/>                    return fut.result()<br/>                else:<br/>                    fut.remove_done_callback(cb)<br/>                    fut.cancel()<br/>                    raise<br/>    <br/>            if fut.done():<br/>                return fut.result()<br/>            else:<br/>                fut.remove_done_callback(cb)<br/>                # We must ensure that the task is not running<br/>                # after wait_for() returns.<br/>                # See https://bugs.python.org/issue32751<br/>                await _cancel_and_wait(fut, loop=loop)<br/>                # In case task cancellation failed with some<br/>                # exception, we should re-raise it<br/>                # See https://bugs.python.org/issue40607<br/>                try:<br/>                    fut.result()<br/>                except exceptions.CancelledError as exc:<br/>&gt;                   raise exceptions.TimeoutError() from exc<br/><span class="error">E                   asyncio.exceptions.TimeoutError</span><br/><br/>/usr/lib64/python3.9/asyncio/tasks.py:491: TimeoutError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A]</td>
          <td class="col-duration">1.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e40a280&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e268130&gt;, id = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A#owner&#x27;<br/>type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, controller = &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyHex&#x27;: &#x27;0355237d4af6afc7f139e396329d56a4d1235c94abde9a25782241774c06cccfb6&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;, &#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A#owner&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:io:0x476c81C27036D05cB5ebfe30ae58C23351a61C4A&#x27;, &#x27;publicKeyHex&#x27;: &#x27;0355237d4af6afc7f139e396329d56a4d1235c94abde9a25782241774c06cccfb6&#x27;}], &#x27;proof&#x27;: {}}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf]</td>
          <td class="col-duration">1.49</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e334a30&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf#zAHd7ePaivnaJLK...8321c11ec99403cf#openid&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/&#x27;, &#x27;type&#x27;: &#x27;OpenIdConnectVersion1.0Service&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;https://w3id.org/security/v1&#x27;], &#x27;id&#x27;: &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf&#x27;, &#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf#zAHd7ePaivnaJLK6feRrmrt1JJZb1t6EdeXrhH63hkn4zpAf3&#x27;, &#x27;type&#x27;: &#x27;RsaVerificationKey2018&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\r\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5rdiNoPlx9PkJ3mCrRB5\r\nWckY5AArfMo5OI4TGP+nN74/tVY2xffyb9CZiJqpfNaYAXcXWJuX/brzYeMaa+sA\r\nbFkOMpY4LwHqYZmOrUWvpW/KcTOfvydOwzRjLjVHmWjHeCy5TdupU649r/YRYjKE\r\niPFh9RanXEbKeTDozyoEcrqdmW3onqFJ+U+b7kUd9ys0y5lf9F/mZmFrP+SZp0D6\r\nKgZC/jUR/ACaSv0jdb710BGROobvanTwXr7dLPVKZxbHAnlnftQ5+4Cjy5zxZO8o\r\n/KjKLSjPuO4l55Pth2oLPH7XT+PFUu/ejva1TcgpJooE96ODHLxmO94dgVxFdvtS\r\neQIDAQAB\r\n-----END PUBLIC KEY-----\r\n&#x27;}], &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:t:45e6df15dc0a7d91dcccd24fda3b52c3983a214fb0eed0938321c11ec99403cf#openid&#x27;, &#x27;type&#x27;: &#x27;OpenIdConnectVersion1.0Service&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://openid.example.com/&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044]</td>
          <td class="col-duration">1.49</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e366be0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:47ef0...rmBJWLeECW&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;12nP26c2mLZ4QfB2FMzLRCM8hRaGGB6QufwqM2YKj1R8&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;https://w3id.org/security/v1&#x27;], &#x27;id&#x27;: &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:bba:47ef0798566073ea302b8178943aaa83f227614d6f36a4d2bcd92993bbed6044#z6MkeV3RcLrU6t3XXA1ivvxBGHu8Wzr7g4LmbgrmBJWLeECW&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;12nP26c2mLZ4QfB2FMzLRCM8hRaGGB6QufwqM2YKj1R8&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg]</td>
          <td class="col-duration">0.25</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e3fa1f0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>&gt;                   raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/><span class="error">E                   aries_cloudagent.resolver.base.DIDNotFound: did:cy:7PGGnRdvKKFftSXU3Jw75Vk5npfg not found by HTTPUniversalDIDResolver</span><br/><br/>http_uniresolver/http_universal.py:76: DIDNotFound<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:bid:6cc796b8d6e2fbebc9b3cf9e]</td>
          <td class="col-duration">0.65</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:bid:6cc796b8d6e2fbebc9b3cf9e&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1c13d0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None, did = &lt;DID did:bid:6cc796b8d6e2fbebc9b3cf9e&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:bid:6cc796b8d6e2fbebc9b3cf9e: Driver reported for did:bid:6cc796b8d6e2fbebc9b3cf9e: Cannot retrieve DDO for `did:bid:6cc796b8d6e2fbebc9b3cf9e` from `http://did.bidspace.cn: HTTP/1.1 502 Bad Gateway</span><br/><br/>http_uniresolver/http_universal.py:79: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoiYW55U2lnbmluZ0tleUlkIiwiandrIjp7ImNydiI6InNlY3AyNTZrMSIsImt0eSI6IkVDIiwieCI6ImFHc01HMHU5Rlg2STU0cGVJS3FZb2tqblFQR2hMVVlUT1FOYzNuT3ZFMVEiLCJ5IjoiZmppbHFoZVdRWWtITkU3MHNoTVJ5TURyWnA4RUdDZkVfYUwzaC15Sm1RQSJ9LCJwdXJwb3NlIjpbImF1dGgiLCJnZW5lcmFsIl0sInR5cGUiOiJFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkifV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJlbmRwb2ludCI6Imh0dHA6Ly9hbnkuZW5kcG9pbnQiLCJpZCI6ImFueVNlcnZpY2VFbmRwb2ludElkIiwidHlwZSI6ImFueVR5cGUifV19fV0sInVwZGF0ZV9jb21taXRtZW50IjoiRWlERkM2RE9Ed0JNeG5kX19oMTFSeDRObjFlOHpubFlPUjJhLVBqeUNva2NGZyJ9LCJzdWZmaXhfZGF0YSI6eyJkZWx0YV9oYXNoIjoiRWlBbExNMC1qem1DWi1FcElVZ0laQ2piWk5yMDFfVVBMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19]</td>
          <td class="col-duration">0.72</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;<br/>did = &#x27;did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW...BMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e29c3a0&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, _profile = None<br/>did = &lt;DID did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG...BMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19&gt;<br/><br/>    async def _resolve(self, _profile: Profile, did: DID) -&gt; DIDDoc:<br/>        &quot;&quot;&quot;Resolve DID through remote universal resolver.&quot;&quot;&quot;<br/>        async with aiohttp.ClientSession() as session:<br/>            async with session.get(f&quot;{self._endpoint}/{did}&quot;) as resp:<br/>                if resp.status == 200:<br/>                    doc = await resp.json()<br/>                    LOGGER.info(&quot;Retrieved doc: %s&quot;, doc[&quot;didDocument&quot;])<br/>                    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>                if resp.status == 404:<br/>                    raise DIDNotFound(f&quot;{did} not found by {self.__class__.__name__}&quot;)<br/>    <br/>                text = await resp.text()<br/>&gt;               raise ResolverError(<br/>                    f&quot;Unexecpted status from universal resolver ({resp.status}): {text}&quot;<br/>                )<br/><span class="error">E               aries_cloudagent.resolver.base.ResolverError: Unexecpted status from universal resolver (500): Resolve problem for did:ion:EiC5-1uBg-YC2DvQRbI6eihDvk7DOYaQ08OB0I3jCe9Ydg:eyJkZWx0YSI6eyJwYXRjaGVzIjpbeyJhY3Rpb24iOiJyZXBsYWNlIiwiZG9jdW1lbnQiOnsicHVibGljX2tleXMiOlt7ImlkIjoiYW55U2lnbmluZ0tleUlkIiwiandrIjp7ImNydiI6InNlY3AyNTZrMSIsImt0eSI6IkVDIiwieCI6ImFHc01HMHU5Rlg2STU0cGVJS3FZb2tqblFQR2hMVVlUT1FOYzNuT3ZFMVEiLCJ5IjoiZmppbHFoZVdRWWtITkU3MHNoTVJ5TURyWnA4RUdDZkVfYUwzaC15Sm1RQSJ9LCJwdXJwb3NlIjpbImF1dGgiLCJnZW5lcmFsIl0sInR5cGUiOiJFY2RzYVNlY3AyNTZrMVZlcmlmaWNhdGlvbktleTIwMTkifV0sInNlcnZpY2VfZW5kcG9pbnRzIjpbeyJlbmRwb2ludCI6Imh0dHA6Ly9hbnkuZW5kcG9pbnQiLCJpZCI6ImFueVNlcnZpY2VFbmRwb2ludElkIiwidHlwZSI6ImFueVR5cGUifV19fV0sInVwZGF0ZV9jb21taXRtZW50IjoiRWlERkM2RE9Ed0JNeG5kX19oMTFSeDRObjFlOHpubFlPUjJhLVBqeUNva2NGZyJ9LCJzdWZmaXhfZGF0YSI6eyJkZWx0YV9oYXNoIjoiRWlBbExNMC1qem1DWi1FcElVZ0laQ2piWk5yMDFfVVBMbnd5MHdfT3I0Rks0dyIsInJlY292ZXJ5X2NvbW1pdG1lbnQiOiJFaUJDNGhTMVVHeVNnTmYzbWFMdnNKRUpxX05aQUlKa0pndTNKMTJMeGNESE93In19: {&quot;message&quot;:&quot;Bad Request&quot;,&quot;type&quot;:&quot;request_resolve_identifier&quot;,&quot;code&quot;:&quot;remote_service_error&quot;,&quot;correlationId&quot;:&quot;0HM6THCNO6F3U:00000001&quot;}</span><br/><br/>http_uniresolver/http_universal.py:79: ResolverError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3]</td>
          <td class="col-duration">0.76</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40dff0280&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40df9b310&gt;<br/>id = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-1&#x27;, type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;<br/>controller = &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyJwk&#x27;: &#x27;{&quot;kty&quot;:&quot;EC&quot;,&quot;crv&quot;:&quot;secp256k1&quot;,&quot;x&quot;:&quot;qdVu4dIjLSS2A_dEp7DYovzoTgFSw309yLTrZanR0Mo&quot;,&quot;y&quot;:&quot;jAhMNEKzvITyyXI...EqdVu4dIjLSS2A/dEp7DYovzoTgFSw309yLTrZanR0MqM\nCEw0QrO8hPLJcivXZ6YULPlKIK9LBP2rFNEpWIpgWQ==\n-----END PUBLIC KEY-----&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;created&#x27;: &#x27;2020-07-14T08:25:15Z&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;publicKey&#x27;: [{&#x27;controller&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEqdVu4dIjLSS2A/dEp7DYovzoTgFSw309yLTrZanR0MqM\nCEw0QrO8hPLJcivXZ6YULPlKIK9LBP2rFNEpWIpgWQ==\n-----END PUBLIC KEY-----&#x27;, &#x27;publicKeyJwk&#x27;: &#x27;{&quot;kty&quot;:&quot;EC&quot;,&quot;crv&quot;:&quot;secp256k1&quot;,&quot;x&quot;:&quot;qdVu4dIjLSS2A_dEp7DYovzoTgFSw309yLTrZanR0Mo&quot;,&quot;y&quot;:&quot;jAhMNEKzvITyyXIr12emFCz5SiCvSwT9qxTRKViKYFk&quot;}&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-1&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;}, {&#x27;controller&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAmefTYRNzfzrmy7rnyf8WrGg0AnS9McZc\n79xN9W901R4G9U7Ci36N216dhkQS2FiTzYjlcHwDnv8X7lkN1LokfFRR0Q96m11nrvbkmd4lrTsa\nngGHZm+9lLSrjlAbXO+h6lA7aPK0/Vu0HZtdEmXF8RzsxjHhwY6U8hgGGotTjEPL96Zntc5fCB52\nCJMGof+sg5xnu8PxW2/z4Pqkw0n6JWhqg8xVy+vq0FYqtbLOKPHpfSKECG7PnNYqImlnHRQd5r+j\nEtMPFkrT78Unm9lPWIhuVyt1S17hmkJColBNsO+f0G1NE1FE+RALcrZ99Mjc9sb9BYK7L1qk9RW7\n2nLmIBrpu327ZPYQA765bYKLIUq3ItmqR14KlKGHPmlIe6tEE8XrRxT2HYShB19xgLL9tgSkr+wd\nNXmzCSM1GFTMkRh3mOa3BZvqnVgSaJjjeMilPzTDNcbHRqEsj9qbx35Svi02qINBLuXGLQTCitto\nCqfOcxvn37e6QMcLXXkfraOGLhk4RGrjUvvlLN1YmOJdbqeczuIhIdn2ylER4y2ZKYZidjcnUvug\ndF3reduTQscwUV9ZObs13awtjVaAZxnb1DOXu5iKDutqoH+T44JVYAZTYubyyHk2zekO+aTRYMSw\nYKpbqMPbfI9TJ4Nt0RB4QLW/ibBMdH/+FIA10y3TBsUCAwEAAQ==\n-----END PUBLIC KEY-----&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-2&#x27;, &#x27;type&#x27;: &#x27;RsaVerificationKey2018&#x27;}, {&#x27;controller&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEz2u9bUwDLvDwu6kn5IJ6ualJ75Et7BaAyVhBEhulVPcA\n2DZaXZUTk+2EpipXvEpMw5WVSY6dFXgYhIth9u5bSg==\n-----END PUBLIC KEY-----&#x27;, &#x27;publicKeyJwk&#x27;: &#x27;{&quot;kty&quot;:&quot;EC&quot;,&quot;crv&quot;:&quot;secp256k1&quot;,&quot;x&quot;:&quot;z2u9bUwDLvDwu6kn5IJ6ualJ75Et7BaAyVhBEhulVPc&quot;,&quot;y&quot;:&quot;ANg2Wl2VE5PthKYqV7xKTMOVlUmOnRV4GISLYfbuW0o&quot;}&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#iot-1&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;}, {&#x27;controller&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEbAjFl3tl5IbSwPTw8viMoO9RTMpLTcezAfcZU7C4\nzmLcAUOrLyYElwdmCgeNyJ2Ff6XvN2BtgRlBrnOnHB8nuQ==\n-----END PUBLIC KEY-----&#x27;, &#x27;publicKeyJwk&#x27;: &#x27;{&quot;kty&quot;:&quot;EC&quot;,&quot;crv&quot;:&quot;P-256&quot;,&quot;x&quot;:&quot;bAjFl3tl5IbSwPTw8viMoO9RTMpLTcezAfcZU7C4zmI&quot;,&quot;y&quot;:&quot;3AFDqy8mBJcHZgoHjcidhX-l7zdgbYEZQa5zpxwfJ7k&quot;}&#x27;, &#x27;id&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-3&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256r1VerificationKey2019&#x27;}], &#x27;proof&#x27;: {&#x27;creator&#x27;: &#x27;did:ace:0xf81c16a78b257c10fddf87ed4324d433317169a005ddf36a3a1ba937ba9788e3#selfIssued-1&#x27;, &#x27;created&#x27;: &#x27;2020-07-14T08:25:16Z&#x27;, &#x27;type&#x27;: &#x27;LinkedDataSignature2015&#x27;, &#x27;signatureValue&#x27;: &#x27;MEQCIDiWhWaHte+/G/9emToSx6JwYG7OWEGCm5u1P1QXUfs2AiAQzp+gO1nLaEMKHQ22bxxT9T9pnm0bIfYHbqeAHsKXxA==&#x27;}, &#x27;@context&#x27;: &#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;updated&#x27;: &#x27;2020-07-14T08:25:15Z&#x27;}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c154ef0c78]</td>
          <td class="col-duration">0.38</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c154ef0c78&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e192e80&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;MyIdEventVerifier&#x27;]}], &#x27;id&#x27;: &#x27;did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c1...+kM6dnIiTWjy+X4IDt5MOGwNofzDCxqVO6ylSLFDTWXJ7iv18GyeJW+L2fCmSqkUIifUuaG23OP0GneU=&#x27;, &#x27;revoked&#x27;: 0, ...}], &#x27;service&#x27;: []}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;authentication&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;], &#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/2019/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:icon:02:6f7a00a29deb82cb36d501d687c18bad79a8f1c154ef0c78&#x27;, &#x27;service&#x27;: [], &#x27;authentication&#x27;: [{&#x27;publicKey&#x27;: [&#x27;MyIdEventVerifier&#x27;]}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;MyIdEventVerifier&#x27;, &#x27;type&#x27;: &#x27;Secp256k1VerificationKey&#x27;, &#x27;created&#x27;: 10787133, &#x27;publicKeyBase64&#x27;: &#x27;BNCLnQY+kM6dnIiTWjy+X4IDt5MOGwNofzDCxqVO6ylSLFDTWXJ7iv18GyeJW+L2fCmSqkUIifUuaG23OP0GneU=&#x27;, &#x27;revoked&#x27;: 0}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC]</td>
          <td class="col-duration">0.42</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40e1a5d90&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;DIDDocSchema(many=False)&gt;<br/>data = {&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#key1&#x27;, &#x27;publ...d&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#resolver&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://www.citln.cn&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;}]}<br/><br/>    def _do_load(<br/>        self,<br/>        data: typing.Union[<br/>            typing.Mapping[str, typing.Any],<br/>            typing.Iterable[typing.Mapping[str, typing.Any]],<br/>        ],<br/>        *,<br/>        many: bool = None,<br/>        partial: typing.Union[bool, types.StrSequenceOrSet] = None,<br/>        unknown: str = None,<br/>        postprocess: bool = True<br/>    ):<br/>        &quot;&quot;&quot;Deserialize `data`, returning the deserialized result.<br/>        This method is private API.<br/>    <br/>        :param data: The data to deserialize.<br/>        :param many: Whether to deserialize `data` as a collection. If `None`, the<br/>            value for `self.many` is used.<br/>        :param partial: Whether to validate required fields. If its<br/>            value is an iterable, only fields listed in that iterable will be<br/>            ignored will be allowed missing. If `True`, all fields will be allowed missing.<br/>            If `None`, the value for `self.partial` is used.<br/>        :param unknown: Whether to exclude, include, or raise an error for unknown<br/>            fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`.<br/>            If `None`, the value for `self.unknown` is used.<br/>        :param postprocess: Whether to run post_load methods..<br/>        :return: Deserialized data<br/>        &quot;&quot;&quot;<br/>        error_store = ErrorStore()<br/>        errors = {}  # type: typing.Dict[str, typing.List[str]]<br/>        many = self.many if many is None else bool(many)<br/>        unknown = unknown or self.unknown<br/>        if partial is None:<br/>            partial = self.partial<br/>        # Run preprocessors<br/>        if self._has_processors(PRE_LOAD):<br/>            try:<br/>                processed_data = self._invoke_load_processors(<br/>                    PRE_LOAD, data, many=many, original_data=data, partial=partial<br/>                )<br/>            except ValidationError as err:<br/>                errors = err.normalized_messages()<br/>                result = (<br/>                    None<br/>                )  # type: typing.Optional[typing.Union[typing.List, typing.Dict]]<br/>        else:<br/>            processed_data = data<br/>        if not errors:<br/>            # Deserialize data<br/>            result = self._deserialize(<br/>                processed_data,<br/>                error_store=error_store,<br/>                many=many,<br/>                partial=partial,<br/>                unknown=unknown,<br/>            )<br/>            # Run field-level validation<br/>            self._invoke_field_validators(<br/>                error_store=error_store, data=result, many=many<br/>            )<br/>            # Run schema-level validation<br/>            if self._has_processors(VALIDATES_SCHEMA):<br/>                field_errors = bool(error_store.errors)<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=True,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>                self._invoke_schema_validators(<br/>                    error_store=error_store,<br/>                    pass_many=False,<br/>                    data=result,<br/>                    original_data=data,<br/>                    many=many,<br/>                    partial=partial,<br/>                    field_errors=field_errors,<br/>                )<br/>            errors = error_store.errors<br/>            # Run post processors<br/>            if not errors and postprocess and self._has_processors(POST_LOAD):<br/>                try:<br/>                    result = self._invoke_load_processors(<br/>                        POST_LOAD,<br/>                        result,<br/>                        many=many,<br/>                        original_data=data,<br/>                        partial=partial,<br/>                    )<br/>                except ValidationError as err:<br/>                    errors = err.normalized_messages()<br/>        if errors:<br/>            exc = ValidationError(errors, data=data, valid_data=result)<br/>            self.handle_error(exc, data, many=many, partial=partial)<br/>&gt;           raise exc<br/><span class="error">E           marshmallow.exceptions.ValidationError: {&#x27;publicKey&#x27;: [&#x27;VerificationMethod Map must have id, type &amp; controler&#x27;]}</span><br/><br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:904: ValidationError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC&#x27;, &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#resolver&#x27;, &#x27;type&#x27;: &#x27;DIDResolve&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://www.citln.cn&#x27;}], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:vaa:3wJVWDQWtDFx27FqvSqyo5xsTsxC#key1&#x27;, &#x27;type&#x27;: &#x27;RsaVerificationKey2018&#x27;, &#x27;publicKeyPem&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDb/A4iQ0Lq6NU9Q3i91vbqZ8jh\nUj/Hr64683e9NvNkFBeFePp7wfuZJRSTMrllP5LEQwXPmeZzQBJjKkY34iQV7EXA\nARKMisvqUR/ucU1mj7ZCiFM+MNCcxn+eD1WfBsXMYfne/BPJPhIUfjjIzBaTQuhI\ntLhGD6WrDv6fovK/GQIDAQAB\n-----END PUBLIC KEY-----\n&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:unisot:test:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4]</td>
          <td class="col-duration">0.56</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">resolver = &lt;http_uniresolver.http_universal.HTTPUniversalDIDResolver object at 0x7fe40edaeac0&gt;, did = &#x27;did:unisot:test:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;<br/>caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x7fe40df9b670&gt;<br/><br/>    @pytest.mark.int<br/>    @pytest.mark.asyncio<br/>    @pytest.mark.parametrize(<br/>        &quot;did&quot;,<br/>        TEST_DIDS<br/>    )<br/>    async def test_resolve_and_load(resolver, did, caplog):<br/>        &quot;&quot;&quot;Test resolution and schema parsing.&quot;&quot;&quot;<br/>        caplog.set_level(logging.INFO)<br/>&gt;       await asyncio.wait_for(resolver.resolve(None, did), timeout=20)<br/><br/>int/test_resolution.py:44: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>/usr/lib64/python3.9/asyncio/tasks.py:478: in wait_for<br/>    return fut.result()<br/>../cloudagent-python/aries_cloudagent/resolver/base.py:71: in resolve<br/>    return await self._resolve(profile, did)<br/>http_uniresolver/http_universal.py:74: in _resolve<br/>    return DIDDoc.deserialize(doc[&quot;didDocument&quot;])<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/diddoc.py:147: in deserialize<br/>    did_doc = schema.load(json)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:722: in load<br/>    return self._do_load(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:856: in _do_load<br/>    result = self._deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:664: in _deserialize<br/>    value = self._call_and_store(<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:493: in _call_and_store<br/>    value = getter_func(data)<br/>env/lib64/python3.9/site-packages/marshmallow/schema.py:661: in &lt;lambda&gt;<br/>    getter = lambda val: field_obj.deserialize(<br/>env/lib64/python3.9/site-packages/marshmallow/fields.py:342: in deserialize<br/>    output = self._deserialize(value, attr, data, **kwargs)<br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/schemas/verificationmethodschema.py:93: in _deserialize<br/>    value[idx] = VerificationMethod(**val)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;aries_cloudagent.connections.models.diddoc_v2.verification_method.VerificationMethod object at 0x7fe40e1c19d0&gt;, id = &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#key1&#x27;<br/>type = &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, controller = &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;, value = None, authn = False<br/>kwargs = {&#x27;publicKeyBase58&#x27;: &#x27;KmtFiGC5VCbvM3Hk3ibeZxBN5ZDu8cDRR3QRakRaMqxMUUxK7FKx7TSxYLBJ5WNEntFzNTPdNHVssMfDUE3NJo2971&#x27;}<br/><br/>    def __init__(<br/>        self,<br/>        id: str,<br/>        type: PublicKeyType,<br/>        controller: Union[str, Sequence],<br/>        value: str = None,<br/>        authn: bool = False,<br/>        **kwargs<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;<br/>        Retain key specification particulars.<br/>    <br/>        Args:<br/>            did: DID of DID document embedding public key<br/>            ident: identifier for public key<br/>            value: key content, encoded as key specification requires<br/>            pk_type: public key type (enum), default ED25519_SIG_2018<br/>            controller: controller DID (default DID of DID document)<br/>            authn: whether key as has DID authentication privilege (default False)<br/>    <br/>        Raises:<br/>            ValueError: on any bad input DID.<br/>    <br/>        &quot;&quot;&quot;<br/>        # Validation process<br/>        DIDUrl.parse(id)<br/>    <br/>        self._id = id<br/>        self._type = type<br/>        self._controller = controller<br/>        self._authn = authn<br/>        if kwargs:<br/>&gt;           value = kwargs.get(PublicKeyType.get(type).specifier)<br/><span class="error">E           AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;specifier&#x27;</span><br/><br/>../cloudagent-python/aries_cloudagent/connections/models/diddoc_v2/verification_method.py:65: AttributeError<br/> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;, &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#key1&#x27;, &#x27;type&#x27;: &#x27;EcdsaSecp256k1VerificationKey2019&#x27;, &#x27;controller&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;KmtFiGC5VCbvM3Hk3ibeZxBN5ZDu8cDRR3QRakRaMqxMUUxK7FKx7TSxYLBJ5WNEntFzNTPdNHVssMfDUE3NJo2971&#x27;}], &#x27;authentication&#x27;: [&#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#key1&#x27;], &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:unisot:n1aAmTXAg4o44Z9k8YCQncEY91r3TV7WU4#service&#x27;, &#x27;type&#x27;: &#x27;VerifiableCredentialService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://service.example.com/vc&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR]</td>
          <td class="col-duration">0.33</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;, &#x27;https://w3id.org/veres-one/v1&#x27;], &#x27;id&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR#z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;8NNydiyd3KjF46ERwY7rycTBvGKRh4J1BbnYvTYCK283&#x27;}], &#x27;capabilityInvocation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR#z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;8NNydiyd3KjF46ERwY7rycTBvGKRh4J1BbnYvTYCK283&#x27;}], &#x27;capabilityDelegation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR#z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;8NNydiyd3KjF46ERwY7rycTBvGKRh4J1BbnYvTYCK283&#x27;}], &#x27;assertionMethod&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR#z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:nym:z6Mkmpe2DyE4NsDiAb58d75hpi1BjqbH6wYMschUkjWDEEuR&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;8NNydiyd3KjF46ERwY7rycTBvGKRh4J1BbnYvTYCK283&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t]</td>
          <td class="col-duration">0.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;, &#x27;https://w3id.org/veres-one/v1&#x27;], &#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t#z6Mkq76ZBzJJjUQCXB2g8RuKSpLji6ssD3v2jj83wifuR56y&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;BeqWbk3sPvujQgBySrwUbinjtXc1oAfg3iD87ShtVrKb&#x27;}], &#x27;capabilityInvocation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t#z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;2noriM5vTwEJvQUsW66Tjuh7cij3kSymecvCR7RoN1NW&#x27;}], &#x27;capabilityDelegation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t#z6Mkg8GSGyco8vQaiUCHymt7UVACDcq8Mbs2sS97W42b2YAg&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;2g1PgjNMoNv7byMbJCvGdPcCQ3ZGwicgBREBfn4a7KPJ&#x27;}], &#x27;assertionMethod&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t#z6Mksn2L6yxeZBrALghomUsxwik7yZpxPLiJvBCgP8mK3ALm&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkgF4uJbLMoUin2uKaBf4Jb1F7SHzuALE8Ldq8FPPpHE9t&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;EKmHWjiDDeMhEBs75uv86dC89zZ6yTTxEAHkYroJ7wZP&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud]</td>
          <td class="col-duration">0.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: [&#x27;https://w3id.org/did/v0.11&#x27;, &#x27;https://w3id.org/veres-one/v1&#x27;], &#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;authentication&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud#z6Mkv74HkqD8epYRZPKGSsVJA6mFGL1w65LmbwcBaJ3qvxmY&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;GeoFAaxhKH3xStUZmJXTK1DFSkk5gC6QuvhFk25q1jzA&#x27;}], &#x27;capabilityInvocation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud#z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;845fadppZ8TD8p6eXhUARchnBkYd7zNkum6zCRNxci8F&#x27;}], &#x27;capabilityDelegation&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud#z6Mkon5H77wMbj8usmdavHbk6k3aRo5bn2whfKF9etTQbwUh&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;AKpEWsgvGBeSmGntEiduFeVacDokN9hLyJLDpcVPgihK&#x27;}], &#x27;assertionMethod&#x27;: [{&#x27;id&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud#z6MkugY88ui8rYGr7Ux8f6SHPbZjTj34nfMS7jJFDmBAYzvQ&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:v1:test:nym:z6MkmWLiAt5FtfwgFJwMDGS1GiFn1KpUXsd7bn1v2hLyXvud&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;GEH5YfThWznNzz7RyXUSYW1je9mDNn75RiPKPVD9dn92&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764]</td>
          <td class="col-duration">1.53</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764&#x27;, &#x27;assertionMethod&#x27;: [&#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764#key-1&#x27;], &#x27;authentication&#x27;: [&#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764#key-1&#x27;], &#x27;publicKey&#x27;: [{&#x27;id&#x27;: &#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764#key-0&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;Dz5LsutgY97gSo64yx7ReCNictXQuQvSqipHNLMcPPo9&#x27;}, {&#x27;id&#x27;: &#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764#key-1&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:factom:testnet:6aa7d4afe4932885b5b6e93accb5f4f6c14bd1827733e05e3324ae392c0b2764&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;AiL9wEJSGHF8UH3rad1keCgFtCQGdgdowRJ9h1JN7LXn&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:schema:public-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J]</td>
          <td class="col-duration">0.32</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:schema:public-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J&#x27;, &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:schema:public-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J#get&#x27;, &#x27;type&#x27;: &#x27;GetSchemaService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://ipfs.infura.io/ipfs/Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:schema:evan-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J]</td>
          <td class="col-duration">1.30</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://www.w3.org/ns/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:schema:evan-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J&#x27;, &#x27;service&#x27;: [{&#x27;id&#x27;: &#x27;did:schema:evan-ipfs:json-schema:Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J#get&#x27;, &#x27;type&#x27;: &#x27;GetSchemaService&#x27;, &#x27;serviceEndpoint&#x27;: &#x27;https://ipfs.evan.network/ipfs/Qma2beXKwZeiUXcaRaQKwbBV1TqyiJnsMTYExUTdQue43J&#x27;}]}<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">int/test_resolution.py::test_resolve_and_load[did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7]</td>
          <td class="col-duration">0.85</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log"> -------------------------------Captured log call-------------------------------- <br/>INFO     http_uniresolver.http_universal:http_universal.py:73 Retrieved doc: {&#x27;@context&#x27;: &#x27;https://w3id.org/did/v1&#x27;, &#x27;id&#x27;: &#x27;did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7&#x27;, &#x27;publicKey&#x27;: [{&#x27;@context&#x27;: [&#x27;https://w3id.org/security/v1&#x27;], &#x27;id&#x27;: &#x27;did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7#keys-1&#x27;, &#x27;type&#x27;: &#x27;Ed25519VerificationKey2018&#x27;, &#x27;controller&#x27;: &#x27;did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7&#x27;, &#x27;publicKeyBase58&#x27;: &#x27;B3FBGKFoQtR9zMkTWggev3wHCWueB292Hjui33a67Ysy&#x27;}], &#x27;authentication&#x27;: [&#x27;did:gatc:2xtSori9UQZdTqzxrkp7zqKM4Kj5B4C7#keys-1&#x27;]}<br/></div></td></tr></tbody></table></body></html>